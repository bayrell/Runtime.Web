/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2021 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web;

use Runtime.BaseObject;
use Runtime.BaseStruct;
use Runtime.Web.Events.ChangeEvent;
use Runtime.Web.Events.WebEvent;
use Runtime.Web.Component;
use Runtime.Web.Message;
use Runtime.Web.RenderDriver;


class Element extends BaseObject
{
	var component = null;
	var controller = null;
	var driver = null;
	string kind = "";
	Collection path_id = null;
	var parent = null;
	var parent_elem = null;
	var childs = new Vector();
	var attrs = new Map();
	var content = null;
	bool is_new_element = false;
	var node = null;
	string elem_name = "";
	
	
	
	/**
	 * Build path id
	 */
	static Collection buildPath(Collection path_id, Dict attrs, int pos)
	{
		string key = attrs["@key"] |> default string "";
		string elem_name = attrs["@elem_name"] |> default string "";
		if (rtl::isEmpty(key)) key = (elem_name != "") ? (elem_name ~ "-" ~ pos) : pos;
		return path_id.pushIm(key);
	}
	
	
	
	/**
	 * Create copy
	 */
	Element copy()
	{
		Element e = new Element();
		e.component = this.component;
		e.controller = this.controller;
		e.driver = this.driver;
		e.path_id = this.path_id;
		e.parent_elem = this.parent_elem;
		return e;
	}
	
	
	
	/**
	 * Create new element
	 */
	Element e(string kind, string elem_name)
	{
		/* Create new element */
		Element e = this.copy();
		e.parent = this;
		e.kind = kind;
		e.elem_name = elem_name;
		
		/* Push element */
		this.childs.pushValue(e);
		
		/* Return */
		return e;
	}
	
	
	
	/**
	 * Set attribute
	 */
	Element a(var obj)
	{
		this.attrs = this.attrs.concat(obj);
		return this;
	}
	
	
	
	/**
	 * Set content function
	 */
	Element c(var content)
	{
		if (rtl::exists(content))
		{
			this.content = content;
		}
		return this;
	}
	
	
	
	/**
	 * Render element
	 */
	Element r()
	{
		/* Node elem */
		var node = null;
		
		/* Build path id */
		this.path_id = static::buildPath(this.parent.path_id, this.attrs, this.parent.childs.count() - 1);
		
		if (this.kind == "element")
		{
			if (this.elem_name != "")
			{
				node = this.controller.findElement(this.parent_elem, this.path_id, "element", this.elem_name);
				if (node == null)
				{
					if (this.elem_name == "svg")
					{
						node = document.@createElementNS("http://www.w3.org/2000/svg", "svg")
					}
					else
					{
						node = document.@createElement(this.elem_name);
					}
					this.is_new_element = true;
				}
				
				/* Set node params */
				node.params = new Map();
				node._path_id = this.path_id;
				node._path_id_str = rs::join(".", this.path_id);
				
				/* Set parent element */
				this.parent_elem = node;
				
				/* Svg */
				if (this.elem_name == "svg")
				{
					var e = document.@createElement("div");
					e.innerHTML = "<svg>" ~ this.content ~ "</svg>";
					var item = e.childNodes[0];
					while (item.childNodes.length > 0)
					{
						var e = item.childNodes[0];
						node.appendChild(e);
					}
				}
				
				/* Set parent component */
				node.component = this.component;
			}
		}
		else if (this.kind == "component")
		{
			node = this.controller.findComponent(this.path_id, this.elem_name);
			if (node == null)
			{
				node = rtl::newInstance(this.elem_name);
				if (node != null)
				{
					node.driver = this.driver;
					node.controller = this.controller;
					node.is_new_element = true;
					this.is_new_element = true;
				}
				else
				{
					#ifdef ES6 then
					log("Component " ~ this.elem_name ~ " not found");
					#endif
				}
			}
			else
			{
				node.is_new_element = false;
			}
			
			/* Model path */
			Collection model_path = [];
			
			/* Find model */
			Collection attr_keys = ["@bind", "@name", "@model"];
			if (this.attrs != null)
			{
				for (int attr_keys_i=0; attr_keys_i<attr_keys.count(); attr_keys_i++)
				{
					string key = attr_keys[attr_keys_i];
					if (this.attrs.has(key))
					{
						model_path = this.controller.findModelPath(this.path_id, this.attrs[key]);
						break;
					}
				}
			}
			
			if (node != null)
			{
				/* Set parent component */
				node.parent = this.component;
				
				/* Set component */
				this.component = node;
				this.component.path_id = this.path_id;
				
				/* Set attrs */
				this.component.old_params = this.component.params;
				this.component.params = new Map();
				
				/* Set model */
				this.component.old_model = this.component.new_model;
				this.component.new_model = this.driver.model(model_path);
				this.component.model_path = model_path;
				this.component.old_watch_model = this.component.new_watch_model;
				
				/* Add component */
				this.controller.addComponent(this.component);
				node.parent.addComponent(node);
			}
		}
		else if (rtl::isFn(this.content))
		{
			fn f = this.content;
			f(this);
		}
		else if (this.content instanceof Collection)
		{
			for (int i=0; i<this.content.count(); i++)
			{
				fn f = this.content[i];
				if (rtl::isFn(f)) f(this);
			}
		}
		else if (this.kind == "text")
		{
			node = this.controller.findElement(this.parent_elem, this.path_id, "text");
			if (node == null)
			{
				node = document.@createTextNode( rtl::exists(this.content) ? this.content : "" );
				node._path_id = this.path_id;
				node._path_id_str = rs::join(".", this.path_id);
			}
			else
			{
				if (node.nodeValue != this.content)
				{
					node.nodeValue = this.content;
				}
			}
		}
		else if (this.kind == "raw")
		{
			node = this.controller::rawHtml(this.content);
		}
		
		/* Set node */
		this.node = node;
		
		/* Set attributes */
		if (this.node != null)
		{
			Collection keys = this.attrs.keys();
			for (int i=0; i<keys.count(); i++)
			{
				string key = keys[i];
				string value = this.attrs[key];
				
				/* Check if event */
				bool is_event = false;
				string event_class_name = "";
				if (rs::substr(key, 0, 7) == "@event:")
				{
					is_event = true;
					event_class_name = rs::substr(key, 7);
				}
				if (rs::substr(0, 12) == "@eventAsync:")
				{
					is_event = true;
					event_class_name = rs::substr(key, 12);
				}
				if (is_event)
				{
					string component_name = value[0] |> default string "";
					string method_name = value[1] |> default string "";
					Component component = this.controller.findParentComponent(this.path_id, component_name);
					if (component)
					{
						if (this.kind == "element")
						{
							string es6_event_name = rtl::applyMethod(event_class_name, "getES6EventName")
								|> default string ""
							;
							if (es6_event_name != "" and this.is_new_element)
							{
								this.node.@addEventListener
								(
									es6_event_name,
									this.controller::event(component, method_name)
								);
							}
						}
						else if (this.kind == "component")
						{
							this.component.addEventListener
							(
								event_class_name,
								this.controller::event(component, method_name)
							);
						}
					}
					continue;
				}
				
				if (key == "@bind" or key == "@name")
				{
					string component_name = value[0] |> default string "";
					string value_name = value[1];
					Component component = this.controller.findParentComponent(this.path_id, component_name);
					if (this.kind == "component")
					{
						this.component.addEventListener
						(
							classof ChangeEvent,
							this.controller::eventChangeComponent(component, value_name)
						);
					}
				}
				
				if (key == "@ref" or key == "@name")
				{
					string component_name = value[0] |> default string "";
					string value_name = value[1] |> default string "";
					Component component = this.controller.findParentComponent(this.path_id, component_name);
					if (component) component[value_name] = node;
				}
				
				if (key == "value" or key == "@bind" or key == "@name")
				{
					if (this.node.tagName == "INPUT" or this.node.tagName == "SELECT" or this.node.tagName == "TEXTAREA")
					{
						if (value == null and this.node.value != "" and value !== 0 and value !== "0")
						{
							this.node.value = "";
						}
						else if (this.node.value != value)
						{
							this.node.value = value;
						}
						this.node._old_value = value;
						continue;
					}
				}
				
				if (this.kind == "component" and key == "@watch")
				{
					node.watchModel(this.path_id, value);
					continue;
				}
				
				if (key[0] == "@") continue;
				if (key == "style" and value instanceof Dict)
				{
					value = rs::join(";", value.transition(string (string v, string k) => k ~ ": " ~ v));
				}
				if (this.kind == "element")
				{
					if (this.node.@getAttribute(key) != value)
					{
						this.node.@setAttribute(key, value);
					}
					node.params.setValue(key, value);
				}
				else if (this.kind == "component")
				{
					node.params.setValue(key, value);
				}
			}
		}
		
		/* Remove old attributes */
		if (this.node != null and this.kind == "element")
		{
			Dict attr_keys = this.attrs.keys();
			for (int i=this.node.attributes.length - 1; i>=0; i--)
			{
				var attr = this.node.attributes[i];
				int pos = attr_keys.find
				(
					bool (string name) use (attr) => rs::strtolower(name) == rs::strtolower(attr.name)
				);
				if (pos == -1)
				{
					this.node.@removeAttribute(attr.name);
				}
			}
		}
		
		/* Render */
		if (this.kind == "component" and this.node != null)
		{
			this.component.repaint(this);
			
			/* On create */
			if (this.is_new_element) this.node.onCreate();
			
			/* On update */
			this.node.onUpdate();
		}
		
		return this;
	}
	
	
	
	/**
	 * Return child nodes
	 */
	Collection getChildNodes()
	{
		Vector childs = new Vector();
		for (int i=0; i<this.childs.count(); i++)
		{
			Element e = this.childs[i];
			if (e.node instanceof Component or e.node == null)
			{
				var nodes = e.getChildNodes();
				childs.appendVector(nodes);
			}
			else if (e.node instanceof Collection)
			{
				childs.appendVector(e.node);
			}
			else
			{
				childs.pushValue(e.node);
			}
		}
		return childs.toCollection();
	}
	
	
	
	/**
	 * Patch element childs
	 */
	Element p()
	{
		Collection new_childs = this.getChildNodes();
		this.controller.patchElemChilds(this.parent_elem, new_childs);
		return this;
	}
}