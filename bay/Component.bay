/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web.Frontend;

use Runtime.lib;
use Runtime.BaseObject;
use Runtime.BaseStruct;
use Runtime.RuntimeUtils;
use Runtime.Annotations.IntrospectionClass;
use Runtime.Interfaces.ContextInterface;
use Runtime.Web.LayoutModel;
use Runtime.Web.RenderHelper;
use Runtime.Web.Events.ChangeEvent;
use Runtime.Web.Events.UIEvent;
use Runtime.Web.Template;


class Component extends BaseObject
{
	public int component_id = 0;
	public Component parent_component = null;
	public string path = "";
	public Dict params = null;
	public var old_model = null;
	public var driver = null;
	public Collection<string> model_bind_path = [];
	
	
	
	/**
	 * Returns model
	 */
	var model(Collection<string> path = null, var def_val = null) =>
		this.model_bind_path == null ? null :
			rtl::attr(this.driver.layout_model, this.model_bind_path.concat(path), def_val)
	;
	
	
	
	/**
	 * Returns module name
	 */
	pure string moduleName() => static::getCurrentNamespace();
	pure string getModuleName()
	{
		string class_name = static::getCurrentClassName();
		IntrospectionClass info = RuntimeUtils::getClassIntrospection(class_name);
		
		Template t = info.class_info.findItem( lib::isInstance( classof Template ) );
		if (t != null and t.module_name != "") return t.module_name;
		
		return static::moduleName();
	}
	
	
	
	/**
	 * Returns model name
	 */
	pure string modelName() => classof BaseStruct;
	pure string getModelName()
	{
		string class_name = static::getCurrentClassName();
		IntrospectionClass info = RuntimeUtils::getClassIntrospection(class_name);
		
		Template t = info.class_info.findItem( lib::isInstance( classof Template ) );
		if (t != null and t.model_name != "") return t.model_name;
		
		return static::modelName();
	}
	
	
	
	/**
	 * Returns required components
	 */
	pure Collection<string> components() => null;
	
	
	
	/**
	 * Component css
	 */
	pure string css(Dict<string> vars) => "";
	
	
	
	/**
	 * Component render
	 */
	pure html render(LayoutModel layout, BaseStruct model, Dict params, html content) => null;
	
	
	
	/**
	 * Returns css name
	 */
	pure string getCssName(string css_name)
	{
		string class_name = static::getCurrentClassName();
		return RenderHelper::getCssName(class_name, css_name);
	}
	
	
	
	/**
	 * Escape attr
	 */
	pure string escapeAttr(string s)
	{
		return rs::escapeHtml(s);
	}
	
	
	
	/**
	 * Escape html
	 */
	pure string escapeHtml(var s)
	{
		#switch
		#case ifcode PHP then
		if ($s instanceof \Runtime\RawString) return $s->toString();
		#endswitch
		if (rtl::isString(s)) return rs::escapeHtml(s);
		if (s instanceof Collection) return rs::join("", s);
		return rs::escapeHtml( rtl::toString(s) );
	}
	
	
	
	/**
	 * Json encode
	 */
	pure string json_encode(var obj)
	{
		return RuntimeUtils::json_encode(obj);
	}
	
	
	
	/**
	 * To html
	 */
	pure string toHtml(var s)
	{
		if (rtl::isString(s)) return s;
		if (s instanceof Collection) return rs::join("", s);
		return rtl::toString(s);
	}
	
	
	#ifdef FRONTEND then
	
	
	/**
	 * Update component
	 */
	public void onUpdate(bool created)
	{
	}
	
	
	
	/**
	 * Set new component's model
	 */
	public void driverSetModel(Collection<string> model_bind_path)
	{
		this.model_bind_path = model_bind_path;
	}
	
	
	
	/**
	 * Set new params
	 */
	public void driverSetParams(Dict params)
	{
		this.params = params;
	}
	
	
	
	/**
	 * Set model
	 * @param var map
	 */
	public void setModel(var model)
	{
		this.driver.setModel(this.model_bind_path, model);
	}
	
	
	
	/**
	 * Update current model
	 * @param Dict map
	 */
	public void updateModel(Dict map)
	{
		this.driver.updateModel(this.model_bind_path, map);
	}
	
	
	
	/**
	 * Update model value
	 */
	public void updateModelValue(Collection<string> path, var value)
	{
		this.driver.updateModelValue(this.model_bind_path.concat(path), value);
	}
	
	
	
	/**
	 * Signal out
	 */
	public void signal(UIEvent e)
	{
		string class_name = e.getClassName();
		string method_name = "";
		
		e <= instance <= this;
		e <= instance_id <= 0;
		
		if (this.params == null) return;
		
		if (e instanceof ChangeEvent)
		{
			if (this.params.has("@bind"))
			{
				string bind = this.params.item("@bind");
				this.driver.updateModelValue(this.model_bind_path, e.value);
			}
		}
		
		method_name = this.params.get("@event:" ~ class_name, "");
		if (method_name != "")
		{
			fn f = this.driver.@searchEventMethod(this.parent_component.path, method_name);
			if (f) f(e);
		}
		
		method_name = this.params.get("@eventAsync:" ~ class_name, "");
		if (method_name != "")
		{
			fn f = this.driver.@searchEventMethod(this.parent_component.path, method_name);
			if (f) rtl::applyAwait(f, [e]);
		}
	}
	
	#endif
	
	
	/**
	 * Send rpc message
	 * @param Dict items
	 * @return Message
	 */ 
	async fn sendMessage(Dict items) => @ -> await method sendMessage(items);
	
}