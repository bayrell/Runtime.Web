/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2023 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web;

use Runtime.lib;
use Runtime.BaseObject;
use Runtime.BaseStruct;
use Runtime.Web.Message;
use Runtime.Web.RenderProvider;
use Runtime.Web.Events.CommitModelEvent;


class Component extends BaseObject
{
	Collection model_path = [];
	var old_model = null;
	var params = null;
	var content = null;
	var vdom = null;
	
	
	/**
	 * Returns layout
	 */
	var layout(Collection<string> model_path = null)
	{
		RenderProvider provider = @.provider(classof RenderProvider);
		if (model_path == null) return provider.layout;
		return rtl::attr(provider.layout, this.model_path.concat(model_path));
	}
	
	
	/**
	 * Returns model by model path
	 */
	var model(Collection<string> model_path = null)
	{
		if (model_path == null) model_path = [];
		var layout = this.layout();
		return rtl::attr(layout, this.model_path.concat(model_path));
	}
	
	
	#ifdef FRONTEND then
	
	
	/**
	 * Returns true if component is changed adn need to repaint
	 */
	bool isChanged(var model, Dict params, var content)
	{
		if (this.old_model != model) return true;
		if (not this.params.equal(params)) return true;
		return false;
	}
	
	
	/**
	 * Update params
	 */
	void updateParams(Collection model_path, Dict params, var content)
	{
		this.model_path = model_path;
		this.params = params;
		this.content = content;
		
		RenderProvider provider = @.provider(classof RenderProvider);
		this.old_model = provider.model(model_path);
	}
	
	
	/**
	 * Create component
	 */
	void onCreate()
	{
		
	}
	
	
	/**
	 * Update component
	 */
	void onUpdate()
	{
		
	}
	
	
	/**
	 * Render component
	 */
	void onRender()
	{
		
	}
	
	
	/**
	 * Commit
	 */
	void commit(string method_name)
	{
		Collection<string> args = null;
		
		#ifcode ES6 then
		args = Runtime.Collection.from( [ ...arguments ].slice(1) );
		#endif
		
		BaseStruct old_model = this.model();
		BaseStruct new_model = null;
		string class_name = old_model::getClassName();
		
		if ( rtl::method_exists(old_model, method_name) )
		{
			fn f = rtl::method(old_model, method_name);
			new_model = rtl::apply(f, args);
		}
		elseif ( rtl::method_exists(class_name, method_name) )
		{
			fn f = rtl::method(class_name, method_name);
			args = args.prependIm(old_model);
			new_model = rtl::apply(f, args);
		}
		
		RenderProvider provider = @.provider(classof RenderProvider);
		provider.commit( this.model_path, new_model );
		
		/* Send commit message */
		Message msg = new Message();
		msg.event = new CommitModelEvent
		{
			"name": method_name,
			"old_model": old_model,
			"new_model": new_model,
		};
		
		/* TODO: must be listener dispatch */
		this.onCommitModel(msg);
	}
	
	
	/**
	 * Repaint Virtual Dom
	 */
	void repaintRef(var ref)
	{
		RenderProvider provider = @.provider(classof RenderProvider);
		provider.repaintRef(ref);
	}
	
	
	/**
	 * Repaint component
	 */
	void repaint()
	{
		RenderProvider provider = @.provider(classof RenderProvider);
		provider.repaintRef(this.vdom);
	}
	
	#endif
	
	
	/**
	 * Returns css
	 */
	static string getCss(Collection<string> class_names, Dict css_vars = null)
	{
		if (css_vars == null) css_vars = {};
		
		/* Get required components */
		Collection<string> components = static::getRequiredComponents(class_names);
		components = components.filter(lib::equalNot("")).removeDuplicatesIm();
		
		/* Get css */
		Collection<string> css = components.map
		(
			string (string component_name) use (css_vars)
			{
				if (component_name == "") return "";
				if (not rtl::method_exists(component_name, "css")) return "";
				fn f = rtl::method(component_name, "css");
				string css = f(css_vars);
				return css;
			}
		);
		
		css = css
			.map( string (string s) => rs::trim(s) )
			.filter( bool (string s) => s != "" )
		;
		
		return rs::join("\n", css);
	}
	
	
	/**
	 * Returns required modules
	 * @param string class_name
	 * @return Collection<string>
	 */
	static void _getRequiredComponents
	(
		Vector<string> res,
		Map<string> cache,
		Collection<string> components
	)
	{
		if (components == null)
			return;
		
		for (int i=0; i<components.count(); i++)
		{
			string class_name = components.item(i);
			if (cache.get(class_name, false) == false)
			{
				cache.setValue(class_name, true);
				if (rtl::method_exists(class_name, "components"))
				{
					fn f = rtl::method(class_name, "components");
					Collection<string> sub_components = f();
					if (sub_components != null)
					{
						static::_getRequiredComponents(res, cache, sub_components);
					}
				}
				res.pushValue(class_name);
			}
		}
	}
	
	
	/**
	 * Returns all components
	 * @param Collection<string> components
	 * @return Collection<string>
	 */
	pure Collection<string> getRequiredComponents(Collection<string> components)
	{
		components = components.filter(lib::equalNot("")).removeDuplicatesIm();
		Vector<string> res = new Vector();
		Map<string> cache = new Map();
		static::_getRequiredComponents(res, cache, components);
		res = res.removeDuplicatesIm();
		return res.toCollection();
	}
	
	
	/**
	 * Retuns css hash
	 * @param string component class name
	 * @return string hash
	 */
	static memorize string hash(string s)
	{
		string r = "";
		string a = "1234567890abcdef";
		int sz = rs::strlen(s);
		int h = 0;
		for (int i=0; i<sz; i++)
		{
			int c = rs::ord( rs::substr(s, i, 1) );
			h = ((h << 2) + (h >> 14) + c) & 65535;
		}
		int p = 0;
		while (h != 0 or p < 4)
		{
			int c = h & 15;
			h = h >> 4;
			r ~= rs::substr(a, c, 1);
			p = p + 1;
		}
		return r;
	}
	
	
	/**
	 * Returns css hash
	 */
	pure memorize string getCssHash() =>
		rtl::getParents(static::getClassName())
			|> .filter
			(
				bool (string class_name) =>
					class_name != "Runtime.BaseObject" and
					class_name != "Runtime.Web.Component"
			)
			|> .map
			(
				string (string class_name) => "h-" ~ static::hash(class_name)
			)
			|> lib::join(" ")
		;
	
	
	/**
	 * Escape html
	 */
	pure string _escape_html(var s)
	{
		#switch
		#case ifcode PHP then
		if (gettype($s) == "array") return $s;
		if ($s instanceof \Runtime\RawString) return $s;
		#endswitch
		if (rtl::isString(s)) return rs::escapeHtml(s);
		if (s instanceof Collection) return rs::join("", s);
		return rs::escapeHtml( rtl::toString(s) );
	}
	
	
	/**
	 * To html
	 */
	pure string _to_html(var s)
	{
		return s;
	}
	
	
	/**
	 * Concat attr
	 */
	pure Dict _concat_attrs(Dict arr1, var arr2)
	{
		if (rtl::isString(arr2)) arr2 = [ arr2 ];
		return arr1.concat(arr2);
	}
	
	
	/**
	 * Merge attrs
	 */
	pure Dict _merge_attrs(Dict res, Dict attr2)
	{
		if (not rtl::exists(attr2)) return res;
		#ifcode JAVASCRIPT then
		return Object.assign(res, attr2.toObject());
		#endif
		return res;
	}
	
	
	/**
	 * Join attrs to string
	 */
	pure string _join_attrs(Dict attrs) =>
		rtl::exists(attrs) ?
			rs::join
			(
				" ",
				attrs.map(
					string (string k, string v) => k ~ "= '" ~ static::_escape_attr(v) ~ "'"
				)
			) : ""
	;
	
	
	/**
	 * Escape attr
	 */
	pure string _escape_attr(var s)
	{
		if (s instanceof Dict)
		{
			s = s.reduce
			(
				string (string s, string val, string key) => s ~ key ~ ":" ~ val ~ ";",
				""
			);
		}
		return rs::escapeHtml(s);
	}
	
	
	#ifcode PHP then
	static function _p(&$arr1, $s)
	{
		if (gettype($s) == "string" || $s instanceof \Runtime\RawString)
		{
			$arr1[] = $s;
		}
		if (gettype($s) == "array")
		{
			foreach ($s as $v) $arr1[] = $v;
		}
	}
	#endif
	
}
