/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 
namespace Runtime.Web.Backend;

use Runtime.lib;
use Runtime.re;
use Runtime.Context;
use Runtime.CoreStruct;
use Runtime.RuntimeUtils;
use Runtime.Annotations.IntrospectionInfo;
use Runtime.Interfaces.AssetsInterface;
use Runtime.Web.Annotations.RouteMiddleware;
use Runtime.Web.Frontend.LayoutModel;
use Runtime.Web.RedirectResponse;
use Runtime.Web.Request;
use Runtime.Web.Response;
use Runtime.Web.RenderContainer;
use Runtime.Web.RenderHelper;
use Runtime.Web.Route;
use Runtime.Web.RouteList;


static class RenderChain
{
	
	/**
	 * Start
	 */
	static RenderContainer start(RenderContainer container)
	{
		if (container.route != null and container.route_params != null) return container;
		
		string uri = container.request.uri;
		bool is_html = rs::substr(uri, -5) == ".html";
		bool is_last_slash = rs::substr(uri, -1) == "/";
		
		if (is_html) return container;
		if (not is_last_slash)
		{
			container <= response <= new RedirectResponse{ "redirect": uri ~ "/" };
		}
		return container;
	}
	
	
	
	/**
	 * Create pocket model
	 */
	static RenderContainer createLayoutModel(RenderContainer container)
	{
		if (container == null) return container;
		if (container.route == null or container.route_params == null) return container;
		if (container.response != null) return container;
		
		/* Set default pattern */
		container <= pattern_name <= "default";
		
		/* Create PocketModel */
		container <= layout <= new LayoutModel
		{
			"bag": new Dict(),
			"uri": RenderHelper::splitRoutePrefix(container.request.uri, container.request.route_prefix),
			"f_inc": @ -> method config(["Runtime.Web", "f_inc"], 1),
			"full_uri": container.request.uri,
			"route": container.route,
			"route_prefix": container.request.route_prefix,
			"route_params": container.route_params,
			"local_bus_gate": container.request.route_prefix ~ "/api",
			"layout_name": "default",
			"frontend_env": {},
		};
		
		return container;
	}
	
	
	
	/**
	 * Create pocket model
	 */
	static RenderContainer setFrontendEnviroment(RenderContainer container)
	{
		if (container.layout == null) return container;
		container <= layout <= frontend_env <= container.layout.frontend_env
			.setIm("route_prefix", container.request.route_prefix)
			.setIm("local_bus_gate", container.request.route_prefix ~ "/api")
		;
		return container;
	}
	
	
	
	/**
	 * Middleware
	 */
	static async RenderContainer callRouteMiddleware(RenderContainer container)
	{
		if (container == null) return container;
		if (container.response != null) return container;
		if (container.route == null or container.route_params == null) return container;
		if (container.route.class_name == "" or container.route.class_method_name == "") return container;
		
		Collection<RouteMiddleware> middlewares = [];
		
		/* Get middleware from class */
		fn getMethodInfoByName = rtl::method(container.route.class_name, "getClassInfo");
		IntrospectionInfo info = getMethodInfoByName();
		middlewares = middlewares.concat
		(
			info.annotations.filter( lib::isInstance(classof RouteMiddleware) )
		)
		
		/* Get middleware from method */
		fn getMethodInfoByName = rtl::method(container.route.class_name, "getMethodInfoByName");
		IntrospectionInfo info = getMethodInfoByName(container.route.class_method_name);
		middlewares = middlewares.concat
		(
			info.annotations.filter( lib::isInstance(classof RouteMiddleware) )
		);
		
		/* Run each middleware */
		for (int i=0; i<middlewares.count(i); i++)
		{
			RouteMiddleware m = middlewares.item(i);
			Collection arr = rs::split("::", m.value);
			string class_name = arr.get(0, "");
			string method_name = arr.get(1, "");
			fn f = rtl::method(class_name, method_name);
			
			/* Run method */
			container = await f(container);
		}
		
		return container;
	}
	
	
	
	/**
	 * Call route
	 */
	static async RenderContainer callRoute(RenderContainer container)
	{
		if (container == null) return container;
		if (container.response != null) return container;
		if (container.route == null or container.route_params == null) return container;
		if (container.route.class_name == "" or container.route.class_method_name == "") return container;
		if (container.layout.page_class != "") return container;
		
		fn f = rtl::method(container.route.class_name, container.route.class_method_name);
		container = await f(container);
		
		return container;
	}
	
	
	
	/**
	 * Init assets
	 */
	static RenderContainer initAssets(RenderContainer container)
	{
		if (container == null) return container;
		if (container.response != null) return container;
		if (container.layout == null) return container;
		if (container.layout.page_class == "") return container;
		
		string layout_class = RenderHelper::getLayoutClassName(container);
		string pattern_class = RenderHelper::getPatternClassName(container);
		
		if (layout_class == "") layout_class = "Runtime.Web.Layout";
		if (pattern_class == "") pattern_class = "Runtime.Web.Backend.Pattern";
		
		/* Get components */
		Collection<string> components = [ layout_class, container.layout.page_class ];
		if (container.layout.components != null) 
		{
			components = components.prependCollectionIm(container.layout.components);
		}
		
		/* Get required assets */
		list res = RenderHelper::getRequiredAssets(container.layout.modules, components);
		Collection<string> modules = res.item(0);
		Collection<string> components = res.item(1);
		Collection<string> assets = modules
			.map(string (string name) => name ~ ".ModuleDescription")
			.filter( lib::classImplements(classof AssetsInterface) )
		;
		
		/* Extends assets */
		if (container.layout.assets != null) 
			assets = modules.prependCollectionIm(container.layout.assets);
		
		container = container.copy({
			"assets": assets,
			"components": components,
			"layout": container.layout.copy({
				"frontend_modules": modules,
				"layout_class": layout_class,
			}),
			"pattern_class": pattern_class,
		});
		
		return container;
	}
	
	
	
	/**
	 * Returns response
	 */
	static RenderContainer response(RenderContainer container)
	{
		if (container == null) return container;
		if (container.response != null) return container;
		if (container.pattern_class == "") return container;
		
		fn f = rtl::method(container.pattern_class, "render");
		string content = f(container);
		
		container <= response <= new Response{ "content": content };
		return container;
	}
	
	
}
