/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web.Backend;

use Runtime.lib;
use Runtime.CoreProvider;
use Runtime.CoreStruct;
use Runtime.Message;
use Runtime.MessageRPC;
use Runtime.RuntimeConstant;
use Runtime.RuntimeUtils;
use Runtime.Annotations.IntrospectionClass;
use Runtime.Annotations.IntrospectionInfo;
use Runtime.Exceptions.ApiException;
use Runtime.Exceptions.RuntimeException;
use Runtime.Interfaces.BusInterface;
use Runtime.Interfaces.ContextInterface;
use Runtime.Web.Annotations.ApiList;
use Runtime.Web.Annotations.ApiMethod;
use Runtime.Web.Annotations.ApiMiddleware;
use Runtime.Web.ApiContainer;
use Runtime.Web.RenderHelper;


struct LocalBusProvider extends CoreProvider implements BusInterface
{
	
	/**
	 * Returns api methods
	 */
	pure Collection<ApiMethod> getApiMethodsByClassName(string class_name)
	{
		IntrospectionClass class_info = RuntimeUtils::getClassIntrospection(class_name);
		
		/* Get routes info */
		Collection<ApiMethod> routes = class_info.methods.map
		(
			ApiMethod (Collection<var> annotations, string class_method_name) use (class_name)
			{
				ApiMethod api_method = annotations.findItem( lib::isInstance( classof ApiMethod ) );
				if (api_method != null)
				{
					string method_name = (api_method.method_name != "") ? api_method.method_name : class_method_name;
					return api_method.copy
					{
						"class_name": class_name,
						"class_method_name": class_method_name,
						"method_name": method_name,
					}
				}
				return null;
			}
		).values();
		
		routes = routes.filter( bool (ApiMethod item) => item != null );
		
		return routes;
	}
	
	
	
	/**
	 * Find api method from list
	 */
	pure ApiMethod findApiMethodFromList(ApiList api_list, MessageRPC msg)
	{
		if (api_list.apiName() != msg.api_name) return null;
		
		bool has_space_name = api_list.space_name != "";
		if (has_space_name and api_list.space_name != msg.space_name) return null;
		
		string class_name = api_list.className();
		if (class_name == "") return null;
		
		/* Returns api methods */
		Collection<ApiMethod> api_methods = static::getApiMethodsByClassName(class_name);
		
		/* Find route */
		for (int i=0; i<api_methods.count(); i++)
		{
			ApiMethod api_method = api_methods.item(i);
			
			if (api_method.method_name != msg.method_name) continue;
			if (not has_space_name and api_method.space_name != msg.space_name) continue;
			
			return api_method.copy
			{
				"api_name": msg.api_name,
				"space_name": msg.space_name,
			}
		}
		
		return null;
	}
	
	
	
	/**
	 * Find api method
	 */
	pure ApiMethod findApiMethod(ApiContainer container)
	{
		if (container.api_method != null) return container;
		
		Collection<CoreStruct> entities = @.entities;
		Collection<ApiList> api_lists = entities.filter( lib::isInstance(classof ApiList) );
		
		for (int api_lists_i=0; api_lists_i<api_lists.count(); api_lists_i++)
		{
			ApiList api_list = api_lists.item(api_lists_i);
			ApiMethod api_method = static::findApiMethodFromList(api_list, container);
			
			if (api_method != null)
			{
				container <= api_method <= api_method;
				break;
			}
		}
		
		return container;
	}
	
	
	
	/**
	 * Api Middleware
	 */
	static async MessageRPC callApiMiddleware(ApiContainer container)
	{
		if (container.api_method == null) return container;
		
		Collection<ApiMiddleware> middlewares = [];
		
		/* Get middleware from class */
		fn getMethodInfoByName = rtl::method(container.api_method.class_name, "getClassInfo");
		IntrospectionInfo info = getMethodInfoByName();
		middlewares = middlewares.concat
		(
			info.annotations.filter( lib::isInstance(classof ApiMiddleware) )
		);
		
		/* Get middleware from method */
		fn getMethodInfoByName = rtl::method(container.api_method.class_name, "getMethodInfoByName");
		IntrospectionInfo info = getMethodInfoByName(container.api_method.class_method_name);
		middlewares = middlewares.concat
		(
			info.annotations.filter( lib::isInstance(classof ApiMiddleware) )
		);
		
		/* Run each middleware */
		for (int i=0; i<middlewares.count(i); i++)
		{
			ApiMiddleware m = middlewares.item(i);
			Collection arr = rs::split("::", m.value);
			string class_name = arr.get(0, "");
			string method_name = arr.get(1, "");
			fn f = rtl::method(class_name, method_name);
			
			/* Run method */
			container = await f(container);
		}
		
		return container;
	}
	
	
	
	/**
	 * Api Run
	 */
	static async MessageRPC callApiRun(ApiContainer container)
	{
		if (container.api_method == null) return container;
		
		fn f = rtl::method(container.api_method.class_name, container.api_method.class_method_name);
		container = await rtl::apply(f, [container]);
		
		return container;
	}
	
	
	
	/**
	 * Api Answer
	 */
	static MessageRPC callApiAnswer(ApiContainer container)
	{
		if (container.api_method == null)
		{
			throw new ApiException(_("App", "Api not found"), RuntimeConstant::ERROR_API_NOT_FOUND);
		}
		
		return container;
	}
	
	
	
	/**
	 * Send Message
	 */
	static fn sendMessage(Message msg) =>
		(msg instanceof MessageRPC) ? static::sendMessageRPC(msg) : msg
	;
	
	
	
	/**
	 * Remote procedure call
	 */
	static fn sendMessageRPC(Message msg) =>
		async Message (LocalBusProvider provider) use (msg)
		{
			msg <= have_answer <= false;
			
			try
			{
				if (not (msg instanceof ApiContainer))
				{
					msg = ApiContainer::create( msg.takeDict() );
				}
				msg <= render_container <= null;
				msg = @ -> await method chainAwait(RenderHelper::API_CHAIN, [msg]);
			}
			catch (ApiException e)
			{
				msg = msg -> method exception(e);
			}
			catch (RuntimeException e)
			{
				msg = msg -> method exception(e);
				msg <= code <= RuntimeConstant::ERROR_FATAL;
			}
			
			msg <= have_answer <= true;
			
			return msg;
		}
	;
	
	
}