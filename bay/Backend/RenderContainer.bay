/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 
namespace Runtime.Web;

use Runtime.lib;
use Runtime.re;
use Runtime.Context;
use Runtime.CoreStruct;
use Runtime.Message;
use Runtime.RuntimeConstant;
use Runtime.RuntimeUtils;
use Runtime.Annotations.IntrospectionClass;
use Runtime.Exceptions.ApiException;
use Runtime.Exceptions.RuntimeException;
use Runtime.Interfaces.AssetsInterface;
use Runtime.Interfaces.BusInterface;
use Runtime.Web.Annotations.Route;
use Runtime.Web.Annotations.RouteList;
use Runtime.Web.ApiContainer;
use Runtime.Web.Cookie;
use Runtime.Web.LayoutModel;
use Runtime.Web.RenderHelper;
use Runtime.Web.Request;
use Runtime.Web.Response;


struct RenderContainer extends Message
{
	Request request = null;
	Response response = null;
	Route route = null;
	Dict<string> route_params = null;
	Dict<Cookie> cookies = null;
	LayoutModel layout = null;
	string pattern_name = "default";
	string pattern_class = "";
	Collection<string> assets = null;
	Collection<string> components = null;
	
	
	
	/**
	 * Send rpc message
	 * @param Dict items
	 * @return Message
	 */ 
	static fn sendMessage(Dict items) =>
		async Message (RenderContainer container) use (items)
		{
			ApiContainer msg = ApiContainer::create(items);
			msg <= render_container <= container;
			
			try
			{
				msg = @ -> await method chainAwait(RenderHelper::API_CONTAINER, [msg]);
			}
			catch (ApiException e)
			{
				msg = msg -> method exception(e);
				msg <= have_answer <= true;
			}
			catch (RuntimeException e)
			{
				msg = msg -> method exception(e);
				msg <= code <= RuntimeConstant::ERROR_FATAL;
				msg <= have_answer <= true;
			}
			
			if (not msg.have_answer)
			{
				msg = @ -> await method send(msg);
			}
			
			return msg;
		}
	;
	
	
	
	/**
	 * Return cookie by name
	 */
	pure memorize Cookie getCookie(string cookie_name, bool only_request = false)
	{
		return RenderContainer (RenderContainer container) use (cookie_name, only_request)
		{
			Cookie cookie = null;
			if (cookie_name == "") return null;
			if (container.request == null) return null;
			if (not only_request and container.cookies != null) cookie = container.cookies.get(cookie_name, null);
			if (cookie == null) cookie = container.request.cookies.get(cookie_name, null);
			return cookie;
		}
	}
	
	
	
	/**
	 * Set cookie
	 */
	pure RenderContainer setCookie(Cookie cookie)
	{
		return RenderContainer (RenderContainer container) use (cookie)
		{
			Dict<Cookie> cookies = container.cookies;
			if (cookies == null) cookies = new Dict<Cookie>();
			cookies = cookies.setIm(cookie.name, cookie);
			container <= cookies <= cookies;
			return container;
		}
	}
	
	
	
	/**
	 * Return api data
	 */
	pure memorize Dict getApiData(RenderContainer container)
	{
		string data1 = container.request.payload.get("DATA", "");
		var data2 = RuntimeUtils::base64_decode_url(data1);
		Dict data3 = RuntimeUtils::json_decode(data2);
		return data3;
	}
	
	
}