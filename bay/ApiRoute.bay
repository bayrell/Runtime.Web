/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2023 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web;

use Runtime.lib;
use Runtime.Exceptions.ApiException;
use Runtime.Web.Annotations.RemoteClass;
use Runtime.Web.Annotations.RemoteMethod;
use Runtime.Web.ApiResult;
use Runtime.Web.BaseRoute;
use Runtime.Web.Bus;
use Runtime.Web.RouteInfo;


class ApiRoute extends BaseRoute
{
	string action = "";
	string method_name = "";
	
	
	/**
	 * Returns routes
	 */
	pure Collection<RouteInfo> getRoutes() =>
	[
		
		new RouteInfo
		{
			"uri": "/api/{api_name}/",
			"params": ["api_name"],
			"name": "runtime:web:api",
			"method": "actionIndex",
		},
		
		new RouteInfo
		{
			"uri": "/api/{api_name}/{remote_name}/",
			"params": ["api_name"],
			"name": "runtime:web:api2",
			"method": "actionIndex",
		},
		
	];
	
	
	/**
	 * Returns api name
	 */
	pure string apiName() => "runtime.web";
	
	
	/**
	 * Returns api methods
	 */
	pure string getApiMethod(string api_name)
	{
		if (api_name == "remote_call") return "actionRemoteCall";
		return "";
	}
	
	
	/**
	 * Action index
	 */
	void actionIndex()
	{
		/* Call method */
		string api_name = this.container.route.matches["api_name"];
		
		/* Decode data */
		var data = this.container.request.payload["data"];
		data = rtl::json_decode(data, false);
		
		/* Call api */
		ApiResult api_result = Bus::callApi(api_name, data);
		this.container.setResponse(api_result);
	}
	
	
	/**
	 * Action remote call
	 */
	async void actionRemoteCall()
	{
		Dict payload = this.container.request.payload;
		string class_name = payload["class_name"];
		string method_name = payload["method_name"];
		Dict post_data = payload["data"];
		
		RemoteClass model = @.entities
			.filter( lib::isInstance(classof RemoteClass) )
			.findItem( lib::equalAttr("name", class_name) )
		;
		
		if (not model)
		{
			return this.container.fail(
				new ApiException("Class '" ~ rs::htmlEscape(class_name) ~ "' not found")
			);
		}
		
		Dict methods = rtl::getMethodsAnnotations(class_name);
		if (not methods.has(method_name))
		{
			return this.container.fail(
				new ApiException("Method '" ~
					rs::htmlEscape(class_name) ~ "::" ~ rs::htmlEscape(method_name) ~
					"' not found")
			);
		}
		
		Collection annotations = methods[method_name];
		RemoteMethod annotation = annotations.findItem( lib::isInstance(classof RemoteMethod) );
		if (not annotation)
		{
			return this.container.fail(
				new ApiException("Method '" ~
					rs::htmlEscape(class_name) ~ "::" ~ rs::htmlEscape(method_name) ~
					"' not found")
			);
		}
		
		fn f = rtl::method(class_name, method_name);
		await f(this.container, post_data);
	}
	
}