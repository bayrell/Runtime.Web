/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 
namespace Runtime.Web;

use Runtime.lib;
use Runtime.re;
use Runtime.Context;
use Runtime.CoreStruct;
use Runtime.RuntimeUtils;
use Runtime.Annotations.IntrospectionClass;
use Runtime.Interfaces.AssetsInterface;
use Runtime.Interfaces.BusInterface;
use Runtime.Web.Annotations.Route;
use Runtime.Web.Annotations.RouteList;
use Runtime.Web.RenderContainer;
use Runtime.Web.Request;


static class RenderHelper
{
	/* Chains */
	static const string RENDER_CHAIN = "Runtime.Web.RenderChain";
	static const string PATTERN_CHAIN = "Runtime.Web.PatternChain";
	static const string LAYOUT_CHAIN = "Runtime.Web.LayoutChain";
	
	/* Pattern */
	static const string PATTERN_HEADER_BEFORE = "Runtime.Web.PatternChain.HeaderBefore";
	static const string PATTERN_HEADER_SEO = "Runtime.Web.PatternChain.HeaderSeo";
	static const string PATTERN_HEADER_AFTER = "Runtime.Web.PatternChain.HeaderAfter";
	static const string PATTERN_BODY_BEFORE = "Runtime.Web.PatternChain.BodyBefore";
	static const string PATTERN_BODY_AFTER = "Runtime.Web.PatternChain.BodyAfter";
	
	/* Render Chain */
	static const int RENDER_CHAIN_START = 500;
	static const int RENDER_CHAIN_CREATE_LAYOUT_MODEL = 1000;
	static const int RENDER_CHAIN_SET_FRONTEND_ENVIROMENTS = 1200;
	static const int RENDER_CHAIN_BEFORE_CALL_ROUTE = 1500;
	static const int RENDER_CHAIN_CALL_ROUTE_PRE = 1500;
	static const int RENDER_CHAIN_CALL_ROUTE = 2000;
	static const int RENDER_CHAIN_CALL_PAGE_NOT_FOUND = 2100;
	static const int RENDER_CHAIN_CALL_ROUTE_POST = 2500;
	static const int RENDER_CHAIN_INIT_ASSETS = 3000;
	static const int RENDER_CHAIN_RESPONSE = 4000;
	static const int RENDER_CHAIN_RESPONSE_POST = 4500;
	
	/* Static Frontend Types */
	static const string FRONTEND_TYPE_DEFAULT = "";
	static const string FRONTEND_TYPE_HOME = "home";
	static const string FRONTEND_TYPE_CATEGORY = "category";
	static const string FRONTEND_TYPE_TAG = "tag";
	static const string FRONTEND_TYPE_ARCHIVE = "archive";
	static const string FRONTEND_TYPE_ARTICLE = "article";
	static const string FRONTEND_TYPE_SEARCH = "search";
	static const string FRONTEND_TYPE_SINLGE = "single_page";
	
	
	
	/**
	 * Retuns css hash
	 * @param string component class name
	 * @return string hash
	 */
	static memorize string getCssHash(string s)
	{
		string r = "";
		string a = "1234567890abcdef";
		int sz = rs::strlen(s);
		int h = 0;
		for (int i=0; i<sz; i++)
		{
			int c = rs::ord( rs::substr(s, i, 1) );
			h = ((h << 2) + (h >> 14) + c) & 65535;
		}
		int p = 0;
		while (h != 0 or p < 4)
		{
			int c = h & 15;
			h = h >> 4;
			r ~= rs::substr(a, c, 1);
			p = p + 1;
		}
		return r;
	}
	
	
	
	/**
	 * Returns css name
	 */
	pure memorize string getCssName(string class_name, string css_name)
	{
		Collection<string> arr = rs::split(" ", css_name);
		Collection<string> class_names = RuntimeUtils::getParents(class_name);
		
		class_names = class_names.filter
		(
			bool (string class_name) =>
				class_name != "Runtime.CoreObject" and class_name != "Runtime.Web.Component"
		);
		
		arr = arr.map
		(
			string (string css_name) use (class_names)
			{
				Collection<string> s1 = class_names.map
				(
					string (string class_name) use (css_name)
					{
						string hash = static::getCssHash(class_name);
						return css_name ~ "-" ~ hash;
					}
				);
				
				string s2 = rs::join(" ", s1);
				return s2;
			}
		);
		
		string name = rs::join(" ", arr);
		return name;
	}
	
	
	
	/**
	 * Escape attr
	 */
	pure string escapeAttr(string s)
	{
		return rs::escapeHtml(s);
	}
	
	
	
	/**
	 * Escape html
	 */
	pure string escapeHtml(var s)
	{
		#switch
		#case ifcode PHP then
		if ($s instanceof \Runtime\RawString) return $s->toString();
		#endswitch
		if (rtl::isString(s)) return rs::escapeHtml(s);
		if (s instanceof Collection) return rs::join("", s);
		return rs::escapeHtml( rtl::toString(s) );
	}
	
	
	
	/**
	 * To html
	 */
	pure string toHtml(var s)
	{
		if (rtl::isString(s)) return s;
		if (s instanceof Collection) return rs::join("", s);
		return rtl::toString(s);
	}
	
	
	
	/**
	 * Json encode
	 */
	pure string json_encode(var obj)
	{
		return RuntimeUtils::json_encode(obj);
	}
	
	
	
	/**
	 * Returns routes
	 */
	pure Collection<Route> getRoutesByClassName(string class_name)
	{
		Vector<Route> routes = new Vector<Route>();
		IntrospectionClass class_info = RuntimeUtils::getClassIntrospection(class_name);
		
		/* Get routes info */
		class_info.methods.each
		(
			void (Collection<Route> annotations, string class_method_name) use (routes, class_name)
			{
				annotations.each
				(
					void (Route route) use (routes, class_name, class_method_name)
					{
						if (route == null) return;
						if (route instanceof Route)
						{
							routes.push
							(
								route.copy
								{
									"class_name": class_name,
									"class_method_name": class_method_name,
								}
							);
						}
					}
				);
			}
		);
		
		return routes.toCollection();
	}
	
	
	
	/**
	 * Returns routes
	 */
	pure Collection<Route> getRoutesByEntities(Collection<CoreStruct> entitites)
	{
		Collection<RouteList> route_lists = entitites.filter( lib::isInstance(classof RouteList) );
		
		Vector<CoreStruct> routes = new Vector();
		routes.appendVector( entitites.filter(lib::isInstance( classof Route )) );
		
		for (int i=0; i<route_lists.count(); i++)
		{
			RouteList route_list = route_lists.item(i);
			string class_name = route_list.className();
			if (class_name == "") continue;
			routes.appendVector( static::getRoutesByClassName(class_name) );
		}
		
		return routes.toCollection();
	}
	
	
	
	/**
	 * Split route prefix
	 */
	pure memorize string splitRoutePrefix(string request_uri, string route_prefix)
	{
		int prefix_len = rs::strlen(route_prefix);
		if (prefix_len > 0)
		{
			int pos = rs::search(request_uri, route_prefix);
			if (pos == -1)
			{
				return null;
			}
			request_uri = rs::substr(request_uri, prefix_len);
		}
		if (request_uri == "") request_uri = "/";
		return request_uri;
	}
	
	
	
	/**
	 * Find route
	 */
	pure list<string, string> findRoute(Collection<Route> routes, Request request)
	{
		Route route = null;
		Dict<string> params = null;
		
		string request_uri = request.uri;
		string route_prefix = request.route_prefix;
		
		request_uri = static::splitRoutePrefix(request_uri, route_prefix);
		if (request_uri === null) return [route, params];
		
		/* Find route */
		for (int i=0; i<routes.count(); i++)
		{
			Route info = routes.item(i);
			Collection<string> matches = re::matchAll( info.uri_match, request_uri );
			if (matches != null)
			{
				matches = matches.map( string (Collection<string> arr) => arr.get(0, "") );
				params = info::getParams(matches, info);
				route = info;
				break;
			}
		}
		
		return [route, params];
	}
	
	
	
	/**
	 * Returns layout class name
	 */
	pure string getLayoutClassName(RenderContainer container)
	{
		string layout_class = container.layout.layout_class;
		if (layout_class != "") return layout_class;
		layout_class = @ -> method chain(RenderHelper::LAYOUT_CHAIN, [ container, "" ]);
		/*layout_class = layouts.get(container.layout.layout_name, "");*/
		return layout_class;
	}
	
	
	
	/**
	 * Returns pattern class name
	 */
	pure string getPatternClassName(RenderContainer container)
	{
		string pattern_class = container.pattern_class;
		if (pattern_class != "") return pattern_class;
		pattern_class = @ -> method chain(RenderHelper::PATTERN_CHAIN, [ container, "" ]);
		/*pattern_class = patterns.get(container.pattern_name, "");*/
		return pattern_class;
	}
	
	
	
	/**
	 * Lazy render
	 */
	pure RenderContainer renderLazy
	(
		string page_class, CoreStruct page_model, string layout_name, RenderContainer container
	)
	{
		return container.copy
		{
			"layout": container.layout.copy
			{
				"page_class": page_class,
				"page_model": page_model,
			},
			"layout_name": layout_name,
		};
	}
	
	
	
	/**
	 * Returns asserts of the components
	 */
	static list<Collection, Collection> getRequiredAssets
	(
		Collection<string> modules, Collection<string> components
	)
	{
		if (modules == null) modules = new Collection<string>();
		
		components = static::getRequiredComponents(components);
		modules = modules.prependCollectionIm
		(
			components.map
			(
				string (string class_name)
				{
					fn f = rtl::method(class_name, "moduleName");
					return f();
				}
			)
		);
		modules = modules.removeDuplicatesIm();
		modules = Context::getRequiredModules(modules);
		
		/* Filter frontend modules */
		modules = modules.filter
		(
			bool (string module_name)
			{
				string class_name = module_name ~ ".ModuleDescription";
				return rtl::class_implements(class_name, classof AssetsInterface);
			}
		);
		
		return [modules, components];
	}
	
	
	
	/**
	 * Returns required modules
	 * @param string class_name
	 * @return Collection<string>
	 */
	static void _getRequiredComponents
	(
		Vector<string> res,
		Map<string> cache,
		Collection<string> components
	)
	{
		if (components == null)
			return;
		
		for (int i=0; i<components.count(); i++)
		{
			string class_name = components.item(i);
			if (cache.get(class_name, false) == false)
			{
				cache.set(class_name, true);
				
				fn f = rtl::method(class_name, "components");
				Dict<string> sub_components = f();
				if (sub_components != null)
				{
					static::_getRequiredComponents(res, cache, sub_components);
				}

				res.push(class_name);
			}
		}
	}
	
	
	
	/**
	 * Returns all components
	 * @param Collection<string> components
	 * @return Collection<string>
	 */
	pure Collection<string> getRequiredComponents(Collection<string> components)
	{
		Vector<string> res = new Vector();
		Map<string> cache = new Map();
		static::_getRequiredComponents(res, cache, components);
		res = res.removeDublicatesIm();
		return res.toCollection();
	}
		
	
}
