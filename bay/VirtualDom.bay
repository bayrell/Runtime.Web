/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2021 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web;

use Runtime.BaseObject;
use Runtime.BaseStruct;
use Runtime.Web.Events.ChangeEvent;
use Runtime.Web.Events.WebEvent;
use Runtime.Web.Component;
use Runtime.Web.Message;
use Runtime.Web.RenderCommand;
use Runtime.Web.RenderController;
use Runtime.Web.RenderDriver;


class VirtualDom extends BaseObject
{
	static const string KIND_ROOT = "root";
	static const string KIND_COLLECTION = "collection";
	static const string KIND_COMPONENT = "component";
	static const string KIND_FUNCTION = "function";
	static const string KIND_ELEMENT = "element";
	static const string KIND_TEXT = "text";
	static const string KIND_RAW = "raw";
	
	int pos = -1;
	string key = "";
	string kind = "";
	string name = "";
	string class_name = "";
	Dict params = null;
	var content = null;
	Collection childs = [];
	Vector new_childs = new Vector();
	var instance = null;
	bool is_change_item = false;
	bool is_change_childs = false;
	RenderController controller = null;
	Collection path_id = null;
	VirtualDom parent_vdom = null;
	
	
	/** 
	 * Constructor
	 */
	public void constructor(Dict obj = null)
	{
		parent();
		static::_assign(this, null, obj);
	}
	
	
	
	/**
	 * Is element
	 */
	public bool isElement() =>
		this.kind == static::KIND_ELEMENT or
		this.kind == static::KIND_TEXT or
		this.kind == static::KIND_RAW
	;
	
	
	
	/**
	 * Returns path name
	 */
	static string buildPathName(string kind, string name, Dict params, int pos)
	{
		if (this.key != "") return this.key;
		if (this.kind == static::KIND_ROOT) return this.name;
		if (this.kind == static::KIND_COMPONENT) return this.name ~ "-" ~ this.pos;
		return this.pos;
	}
	
	
	
	/**
	 * Returns path name
	 */
	string getPathName()
	{
		return static::buildPathName(this.kind, this.name, this.key, this.pos);
	}
	
	
	
	/**
	 * Find element by key
	 */
	VirtualDom findChildElement(string kind, string name, string key, int pos)
	{
		string path_name = static::buildPathName(kind, name, key, pos);
		for (int i=0; i<this.childs.count(); i++)
		{
			VirtualDom item = this.childs[i];
			string item_path_name = item.getPathName();
			if (path_name == item_path_name and item.kind == kind and item.name == name) return item;
		}
		return null;
	}
	
	
	
	/**
	 * Element
	 */
	VirtualDom e(string kind, string name, Dict params, var content = null, Dict opts = null)
	{
		VirtualDom vdom = null;
		params = Dict.@from(params);
		int pos = this.new_childs.count();
		string key = (string) params.get("@key", "");
		
		if (kind == "c") kind = static::KIND_COMPONENT;
		else if (kind == "f") kind = static::KIND_FUNCTION;
		else if (kind == "e") kind = static::KIND_ELEMENT;
		else if (kind == "t") kind = static::KIND_TEXT;
		else if (kind == "r") kind = static::KIND_RAW;
		else return null;
		
		/* Check if function */
		if (content != null and rtl::isFn(content))
		{
			kind = static::KIND_FUNCTION;
		}
		
		/* Find child element */
		vdom = this.findChildElement(kind, name, key, pos);
		
		/* Find element by position */
		if (opts != null and opts.get("is_new", false) != true)
		{
			vdom = this.childs.get(pos, null);
		}
		
		/* Check vdom kind */
		if (vdom != null and vdom.kind != kind) vdom = null;
		
		/* Create new element */
		if (vdom == null)
		{
			vdom = new VirtualDom
			{
				"pos": pos,
				"key": key,
				"kind": kind,
				"name": name,
				"class_name": (params["class"] |> default string ""),
				"controller": this.controller,
				"params": params,
				"content": content,
				"parent_vdom": this,
			};
			vdom.path_id = this.path_id.pushIm( vdom.getPathName() );
			vdom.is_change_item = true;
		}
		
		/* Clear instance */
		if (vdom.kind != kind or vdom.name != name)
		{
			vdom.instance = null;
		}
		
		/* Prepare to repaint */
		vdom.prepareRepaint();
		
		/* Push child */
		this.new_childs.pushValue(vdom);
		
		/* Push component to render */
		if (kind == static::KIND_COMPONENT)
		{
			this.controller.render_partial.pushValue(vdom);
		}
		if (kind == static::KIND_FUNCTION)
		{
			this.controller.render_partial.pushValue(vdom);
		}
		
		/* Push changed value */
		if (vdom.isElement() and vdom.is_change_item)
		{
			this.controller.addRenderVirtualDom(vdom);
		}
		
		return vdom;
	}
	
	
	
	/**
	 * Patch childs
	 */
	void p()
	{
		this.childs = this.new_childs.toCollection();
		this.new_childs = null;
		this.is_change_childs = true;
	}
	
	
	
	/**
	 * Prepare to repaint
	 */
	void prepareRepaint()
	{
		this.new_childs = new Vector();
	}
	
	
	
	/**
	 * Send signal
	 */
	async void signal(var signal)
	{
	}
	
	
	
	/**
	 * Returns childs elements
	 */
	static void _getChildElements(VirtualDom vdom, Vector res, bool new_childs = false)
	{
		Collection childs = null;
		if (new_childs) childs = vdom.new_childs;
		else childs = vdom.childs;
		
		if (childs == null) return;
		
		/* Foreach childs */
		for (int i=0; i<childs.count(); i++)
		{
			VirtualDom item = childs[i];
			if (item.isElement()) res.pushValue(item);
			else if (item.kind == static::KIND_COMPONENT or item.kind == static::KIND_FUNCTION)
			{
				static::_getChildElements(item, res, new_childs);
			}
		}
	}
	
	
	
	/**
	 * Returns childs elements
	 */
	Collection getChildElements(bool new_childs = false)
	{
		Vector res = new Vector();
		static::_getChildElements(this, res, new_childs);
		return res.toCollection();
	}
	
	
	
	/**
	 * Get parent element
	 */
	var getParentElementVirtualDom()
	{
		VirtualDom vdom = this.parent_vdom;
		while (vdom != null and not vdom.isElement() and vdom.kind != static::KIND_ROOT) vdom = vdom.parent_vdom;
		return vdom;
	}
	
	
	
	/**
	 * Get parent component
	 */
	var getParentComponentVirtualDom()
	{
		VirtualDom vdom = this.parent_vdom;
		while (vdom != null and vdom.kind != static::KIND_COMPONENT) vdom = vdom.parent_vdom;
		return vdom;
	}
	
	
	
	/**
	 * Get parent element
	 */
	var getParentElement()
	{
		VirtualDom vdom = this.getParentElementVirtualDom();
		return (vdom != null) ? vdom.instance : null;
	}
	
	
	
	/**
	 * Get parent component
	 */
	var getParentComponent()
	{
		VirtualDom vdom = this.getParentComponentVirtualDom();
		return (vdom != null) ? vdom.instance : null;
	}
	
	
	
	/**
	 * Get current component
	 */
	Component component()
	{
		if (this.kind == VirtualDom::KIND_COMPONENT) return this;
		return this.getParentComponent();
	}
}