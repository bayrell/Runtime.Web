/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2023 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web;

use Runtime.BaseObject;
use Runtime.Web.Component;
use Runtime.Web.RenderProvider;


class VirtualDom extends BaseObject
{
	static const string KIND_ROOT = "root";
	static const string KIND_COLLECTION = "collection";
	static const string KIND_COMPONENT = "component";
	static const string KIND_FUNCTION = "function";
	static const string KIND_ELEMENT = "element";
	static const string KIND_TEXT = "text";
	static const string KIND_RAW = "raw";
	
	string key = "";
	string kind = "";
	string name = "";
	Dict params = null;
	Collection childs = [];
	Vector new_childs = new Vector();
	Collection<string> path_id = null;
	VirtualDom parent_vdom = null;
	Component component = null;
	bool is_new_element = false;
	bool is_changed_item = false;
	bool is_change_childs = false;
	var render = null;
	var elem = null;
	
	
	/**
	 * Returns path id
	 */
	string getPathId() => rs::join(":", this.path_id);
	
	
	/**
	 * Is element
	 */
	public bool isElement() =>
		this.kind == static::KIND_ELEMENT or
		this.kind == static::KIND_TEXT or
		this.kind == static::KIND_RAW
	;
	
	
	/**
	 * Is component
	 */
	public bool isComponent() => this.kind == static::KIND_COMPONENT;
	
	
	/**
	 * Find element by key
	 */
	VirtualDom findChildElement(string key)
	{
		for (int i=0; i<this.childs.count(); i++)
		{
			VirtualDom item = this.childs[i];
			if (item.key == key) return item;
		}
		return null;
	}
	
	
	/**
	 * Return true if vdom is changed
	 */
	bool isChanged(Dict params, var content)
	{
		if (this.kind == static::KIND_COMPONENT and this.component instanceof Component)
		{
			RenderProvider provider = @.provider(classof RenderProvider);
			
			Collection model_path = this.findModelPath(params);
			var model = provider.model(model_path);
			
			return this.elem.isChanged(model, params, content);
		}
		
		if (this.isElement())
		{
			fn f = bool (var value, string key)
			{
				if (rs::indexOf(key, "@event") == 0) return false;
				return true;
			};
			Dict old_params = this.params.filter(f);
			params = params.filter(f);
			
			return not old_params.equal(params) or this.content != content;
		}
		
		return true;
	}
	
	
	/**
	 * Element
	 */
	VirtualDom e(string kind, string name, Dict params, var content = null, Dict opts = null)
	{
		VirtualDom vdom = null;
		params = Dict.@from(params);
		int pos = this.new_childs.count();
		
		/* Get key */
		string key = (string) params.get("@key", "");
		if (key == "" and name == "") key = pos;
		else if (key == "") key = name ~ "-" ~ pos;
		
		/* Get kind */
		if (kind == "c") kind = static::KIND_COMPONENT;
		else if (kind == "f") kind = static::KIND_FUNCTION;
		else if (kind == "e") kind = static::KIND_ELEMENT;
		else if (kind == "t") kind = static::KIND_TEXT;
		else if (kind == "r") kind = static::KIND_RAW;
		else return null;
		
		/* Check if function */
		if (kind == static::KIND_TEXT and content != null and rtl::isFn(content))
		{
			kind = static::KIND_FUNCTION;
		}
		
		/* Check if collection */
		else if (kind == static::KIND_TEXT and content != null and content instanceof Collection)
		{
			kind = static::KIND_COLLECTION;
		}
		
		/* Find child element */
		vdom = this.findChildElement(key);
		
		/* Check vdom kind */
		if (vdom != null and (vdom.kind != kind or vdom.name != name)) vdom = null;
		
		/* Create new element */
		if (vdom == null)
		{
			vdom = new VirtualDom();
			vdom.key = key;
			vdom.kind = kind;
			vdom.name = name;
			vdom.params = params;
			vdom.content = content;
			vdom.parent_vdom = this;
			vdom.path_id = this.path_id.pushIm( key );
			vdom.is_change_childs = false;
			vdom.is_changed_item = true;
			vdom.is_new_element = true;
		}
		else
		{
			vdom.is_new_element = false;
			vdom.is_change_childs = false;
			vdom.is_changed_item = vdom.isChanged(params, content);
			vdom.params = params;
			vdom.content = content;
		}
		
		/* Set element */
		if (not vdom.isElement())
		{
			vdom.elem = this.elem;
		}
		else
		{
			vdom.component = this.component;
		}
		
		/* Clear vdom childs */
		vdom.new_childs = new Vector();
		
		/* Push child */
		this.new_childs.pushValue(vdom);
		
		/* Get render provider */
		RenderProvider provider = @.provider(classof RenderProvider);
		
		/* Add to render_dom_list if vdom is changed */
		if (vdom.is_changed_item)
		{
			if (vdom.isElement())
			{
				provider.addChangedElem(vdom);
			}
			else if (kind == static::KIND_FUNCTION)
			{
				provider.addChangedElem(vdom);
				
				vdom.render = content;
				content(vdom);
				vdom.p();
			}
			else if (kind == static::KIND_COMPONENT)
			{
				string class_name = name;
				Collection model_path = this.findModelPath(params);
				bool is_new = false;
				
				if (vdom.component == null)
				{
					vdom.component = rtl::newInstance(class_name);
					vdom.component.vdom = vdom;
					is_new = true;
				}
				
				Component component = vdom.component;
				
				/* Setup params */
				component.updateParams(model_path, params, content);
				
				/* On create */
				if (is_new) component.onCreate();
				
				/* On update */
				else component.onUpdate();
				
				/* Get render */
				fn render = rtl::method(class_name, "render");
				
				/* Render component */
				fn f = render(component, params, content);
				f(vdom);
				vdom.p();
				
				/* Render event */
				component.onRender();
			}
		}
		
		return vdom;
	}
	
	
	/**
	 * Patch childs
	 */
	void p()
	{
		this.childs = this.new_childs.toCollection();
		this.new_childs = new Vector();
		this.is_change_childs = true;
	}
	
	
	/**
	 * Get parent component
	 */
	var getParentComponentVirtualDom(string class_name = "")
	{
		VirtualDom vdom = this.parent_vdom;
		while
		(
			vdom != null and
			vdom.kind != static::KIND_COMPONENT and
			(
				class_name == "" or
				class_name != "" and vdom.name != class_name
			)
		)
		{
			vdom = vdom.parent_vdom;
		}
		return vdom;
	}
	
	
	/**
	 * Get parent component
	 */
	Component getParentComponent(string class_name = "")
	{
		VirtualDom vdom = this.getParentComponentVirtualDom(class_name);
		return (vdom != null) ? vdom.instance : null;
	}
	
	
	/**
	 * Returns model path
	 */
	Collection<string> findModelPath(Dict params)
	{
		var attr = params["@model"];
		if (not attr) return [];
		
		var component = attr[0];
		var model_path = attr[1];
		return component.model_path.concat(model_path);
	}
	
	
	/**
	 * Returns childs elements
	 */
	static void _getChildElements(VirtualDom vdom, Vector res, bool new_childs = false)
	{
		Collection childs = null;
		if (new_childs) childs = vdom.new_childs;
		else childs = vdom.childs;
		
		if (childs == null) return;
		
		/* Foreach childs */
		for (int i=0; i<childs.count(); i++)
		{
			VirtualDom item = childs[i];
			if (item.isElement()) res.pushValue(item);
			else if (
				item.kind == static::KIND_COMPONENT or
				item.kind == static::KIND_FUNCTION or
				item.kind == static::KIND_COLLECTION
			)
			{
				static::_getChildElements(item, res, new_childs);
			}
		}
	}
	
	
	/**
	 * Returns childs elements
	 */
	Collection getChildElements(bool new_childs = false)
	{
		Vector res = new Vector();
		static::_getChildElements(this, res, new_childs);
		return res.toCollection();
	}
}