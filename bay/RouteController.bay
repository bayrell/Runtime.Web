/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web;

use Runtime.re;
use Runtime.lib;
use Runtime.BaseStruct;
use Runtime.IntrospectionClass;
use Runtime.RuntimeUtils;
use Runtime.Core.CoreDriver;
use Runtime.Core.Request;
use Runtime.Web.FrontendStorageDriver;
use Runtime.Web.RenderContainer;
use Runtime.Web.RenderController;
use Runtime.Web.RenderDriver;
use Runtime.Web.Route;
use Runtime.Web.RouteList;


class RouteController extends CoreDriver
{
	Vector history = null;
	Collection<Route> routes = null;
	string route_prefix = "";
	
	
	/**
	 * Start driver
	 */
	public async void startDriver()
	{
		this.history = new Vector();
		this.routes = static::getRoutesByEntities(@.entities);
		this.route_prefix = @.env("X-ROUTE-PREFIX", "");
		
		#ifcode ES6 then
		
		/* Add mouse listener */
		var body = document.getElementsByTagName("body")[0];
		body.addEventListener("click", Runtime.Web.RouteController.js_click);
		
		/* Add history listener */
		window.onpopstate = Runtime.Web.RouteController.js_onpopstate;
		
		/* Set RouteController */
		window["RouteController"] = this;
		
		#endif
	}
	
	
	
	/**
	 * JS Click Event
	 */
	public static void @js_click(var e)
	{
		@ = RuntimeUtils::getContext();
		RenderController controller = @.getDriver(@, classof RouteController);
		
		#ifcode JAVASCRIPT then
		var elem = e.target;
		while (elem !== null && elem.nodeName !== "A") elem = elem.parentNode;
		if (elem !== null && elem.tagName == "A")
		{
			var target = elem.getAttribute("target");
			var href = elem.getAttribute("href");
			if (target == null)
			{
				e.preventDefault();
				(async () => {
					try { await controller.openUrl(ctx, href); }
					catch (e) { console.log(e.stack); }
				})();
				return false;
			}
		}
		
		#endif
	}
	
	
	
	/**
	 * JS onpopstate event
	 */
	public static void @js_onpopstate(var e)
	{
		@ = RuntimeUtils::getContext();
		RenderController controller = @.getDriver(@, classof RouteController);
		
		#ifcode JAVASCRIPT then
		if (controller.history.count() == 0)
		{
			document.location = document.location;
		}
		else if (e.state != null && typeof e.state.href == "string")
		{
			controller.history.pop(ctx);
			(async () => {
				try { await controller.renderPage(ctx, e.state.href); }
				catch (e) { console.log(e.stack); }
			})();
		}
		else
		{
			controller.history.pop(ctx);
			(async () => {
				try { await controller.renderCurrentPage(ctx); }
				catch (e) { console.log(e.stack); }
			})();
		}
		#endif
	}
	
	
	
	/**
	 * Open url
	 */
	public async void openUrl(string href = "/")
	{
		#ifcode JAVASCRIPT then
		var obj = { "href": href, };
		history.pushState(obj, "", href);
		#endif
		this.history.pushValue(href);
		await this.renderPage(href);
	}
	
	
	
	/**
	 * Render
	 */
	public async void renderFirst()
	{
		bool render = false;
		
		/* Check if need to render */
		Collection<RenderController> controllers = @.getDrivers(classof RenderController);
		for (int i=0; i<controllers.count(); i++)
		{
			RenderController controller = controllers[i];
			if (controller.isMainController() and controller.layout == null)
			{
				render = true;
				break;
			}
		}
		
		/* Render all controllers */
		for (int i=0; i<controllers.count(); i++)
		{
			RenderController controller = controllers[i];
			if (controller.layout != null)
			{
				controller.repaint();
			}
		}
		
		/* render */
		if (render)
		{
			await this.renderCurrentPage();
		}
	}
	
	
	
	/**
	 * Render
	 */
	public async void renderCurrentPage()
	{
		string uri = "/";
		
		#ifcode ES6 then
		uri = window.location.pathname;
		#endif
		
		await this.renderPage(uri);
	}
	
	
	
	/**
	 * Get query keys
	 */
	pure Collection getQueryKeys(string key)
	{
		key = rs::replace("]", "", key);
		Collection arr = rs::split("\\[", key);
		return arr;
	}
	
	
	
	/**
	 * Render page
	 */
	public async void renderPage(string url = "/")
	{
		string host = "";
		string method = "";
		string protocol = "";
		
		#ifcode ES6 then
		host = window.location.hostname;
		protocol = window.location.protocol.substr(0, window.location.protocol.length - 1);
		#endif
		
		int pos = rs::strpos(url, "?");
		string uri = (pos >= 0) ? rs::substr(url, 0, pos) : url;
		string get = (pos >= 0) ? rs::substr(url, pos + 1) : "";
		Dict<string> query = new Map();
		
		if (get != "")
		{
			Collection arr = rs::explode("&", get);
			arr.each
			(
				void (string s) use (query)
				{
					Collection arr = rs::explode("=", s);
					string key = arr[0];
					string value = arr[1];
					Collection keys = static::getQueryKeys(key);
					query = rtl::setAttr(query, keys, value);
				}
			);
		}
		
		Request request = new Request
		{
			"uri": uri,
			"host": host,
			"protocol": protocol,
			"query": query.toDict(),
			"route_prefix": this.route_prefix,
		};
		
		/* Find main controller name */
		string frontend_controller_name = "";
		RenderController controller = RenderDriver::getMainController();
		if (controller)
		{
			frontend_controller_name = controller.getObjectName();
		}
		
		/* Save controllers */
		FrontendStorageDriver driver = @.getDriver(classof FrontendStorageDriver);
		driver.saveControllers();
		
		/* Render request */
		RenderContainer container = await this.renderRequest(request, frontend_controller_name);
		
		/* Render container */
		this.renderContainer(container);
	}
	
	
	
	/**
	 * Render request
	 */
	async RenderContainer renderRequest(Request request, string frontend_controller_name = "")
	{
		Route route = null;
		Dict<string> params = null;
		
		/* Search route */
		list res = this.findRoute(request);
		route = res.item(0); params = res.item(1);
		
		/* Create render container  */
		RenderContainer container = new RenderContainer
		{
			"request": request,
			"route": route,
			"route_params": params,
			"frontend_controller_name": frontend_controller_name,
		};
		
		/* Render container */
		container = await RenderDriver::chainRender(container);
		
		/* Result */
		return container;
	}
	
	
	
	/**
	 * Render container
	 */
	void renderContainer(RenderContainer container)
	{
		RenderController controller = RenderDriver::getMainController();
		if (controller)
		{
			controller.renderLayout(container.layout);
		}
	}
	
	
	
	/**
	 * Find route
	 */
	list<string, string> findRoute(Request request)
	{
		Route route = null;
		Dict<string> params = null;
		
		string request_uri = request.uri;
		string route_prefix = request.route_prefix;
		
		request_uri = RenderDriver::splitRoutePrefix(request_uri, route_prefix);
		if (request_uri === null) return [route, params];
		
		/* Find route */
		for (int i=0; i<this.routes.count(); i++)
		{
			Route info = this.routes.item(i);
			Collection<string> matches = re::matchAll( info.uri_match, request_uri );
			if (matches != null)
			{
				matches = matches.get(0, null);
				if (matches) matches = matches.removeFirstIm();
				params = info::getParams(matches, info);
				route = info;
				break;
			}
		}
		
		return [route, params];
	}
	
	
	
	/**
	 * Returns routes
	 */
	pure Collection<Route> getRoutesByEntities(Collection<BaseStruct> entitites)
	{
		Collection<RouteList> route_lists = entitites.filter( lib::isInstance(classof RouteList) );
		
		Vector<BaseStruct> routes = new Vector();
		routes.appendVector( entitites.filter(lib::isInstance( classof Route )) );
		
		for (int i=0; i<route_lists.count(); i++)
		{
			RouteList route_list = route_lists.item(i);
			string class_name = route_list.className();
			if (class_name == "") continue;
			routes.appendVector( static::getRoutesByClassName(class_name) );
		}
		
		return routes.toCollection();
	}
	
	
	
	/**
	 * Returns routes
	 */
	pure Collection<Route> getRoutesByClassName(string class_name)
	{
		Vector<Route> routes = new Vector<Route>();
		IntrospectionClass class_info = RuntimeUtils::getClassIntrospection(class_name);
		
		/* Get routes info */
		if (class_info) class_info.methods.each
		(
			void (Collection<Route> annotations, string class_method_name) use (routes, class_name)
			{
				annotations.each
				(
					void (Route route) use (routes, class_name, class_method_name)
					{
						if (route == null) return;
						if (route instanceof Route)
						{
							routes.pushValue
							(
								route.copy
								{
									"class_name": class_name,
									"class_method_name": class_method_name,
								}
							);
						}
					}
				);
			}
		);
		
		return routes.toCollection();
	}
	
}