/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2023 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web;

use Runtime.BaseProvider;
use Runtime.Context;
use Runtime.Web.AppHook;
use Runtime.Web.BaseRoute;
use Runtime.Web.Layout;
use Runtime.Web.RenderContainer;
use Runtime.Web.RenderProvider;
use Runtime.Web.RouteList;


class App extends BaseProvider
{
	
	/**
	 * Init app
	 */
	async Context init(Context c)
	{
		return c;
	}
	
	
	/**
	 * Start app
	 */
	async void start()
	{
	}
	
	
	/**
	 * Main entry point
	 */
	async void main()
	{
		await @.callAsyncHook(AppHook::MAIN, {});
		
		#ifcode PHP then
		$container = $this->createRenderContainer();
		$this->init_container($container);
		$this->resolve_container($container);
		$this->response($container->response);
		#endif
		
		#ifcode ES6 then
		let context = Runtime.rtl.getContext();
		let core_ui_root = document.getElementById("core_ui_root");
		let core_ui_layout = document.getElementById("core_ui_layout");
		let layout = Runtime.rs.base64_decode_url(core_ui_layout.value);
		layout = Runtime.rtl.json_decode(layout);
		let layout_page_class_name = layout.constructor.getLayoutPageClass( layout.layout_name );
		let provider = context.provider("Runtime.Web.RenderProvider");
		provider.renderRoot(core_ui_root, layout_page_class_name, layout);
		#endif
	}
	
	
	/**
	 * Resolve container
	 */
	async void init_container(RenderContainer container)
	{
		Context context = @;
		context <= environments <= render_container <= container;
		@ = context;
		
		/* Init container */
		@.callAsyncHook(AppHook::INIT_CONTAINER, {
			"container": container,
		});
	}
	
	
	/**
	 * Resolve container
	 */
	async void resolve_container(RenderContainer container)
	{
		/* Find route */
		await this.findRoute(container);
		
		/* Call route */
		await this.callRoute(container);
		
		/* Call hook response */
		await @.callAsyncHook(AppHook::RESPONSE, {
			"container": container,
		});
	}
	
	
	/**
	 * Create layout
	 */
	async void createLayout(RenderContainer container)
	{
		@.callAsyncHook(AppHook::CREATE_LAYOUT, {
			"container": container,
		});
		
		if (container.layout == null)
		{
			container <= layout <= new Layout();
		}
		
		/* Setup request params */
		container <= layout <= route <= container.route;
		container <= layout <= request_uri <= container.request.uri;
		container <= layout <= request_full_uri <= container.request.full_uri;
		container <= layout <= request_params <= container.request.query;
		
		@.callAsyncHook(AppHook::INIT_LAYOUT, {
			"container": container,
		});
		
		container <= layout <= await container.layout.init_layout();
	}
	
	
	/**
	 * Find route
	 */
	async void findRoute(RenderContainer container)
	{
		/* Call hook find route */
		await @.callAsyncHook(AppHook::FIND_ROUTE, {
			"container": container,
		});
		
		/* Find route */
		if (container.route == null)
		{
			RouteList routes = @.provider(classof RouteList);
			container.route = routes.findRoute( container );
		}
		
		/* Call hook found route */
		await @.callAsyncHook(AppHook::FIND_ROUTE_AFTER, {
			"container": container,
		});
	}
	
	
	/**
	 * Call route
	 */
	async void callRoute(RenderContainer container)
	{
		/* Call middleware */
		if (container.route and container.route.middleware)
		{
			for (int i=0; i<container.route.middleware.count(); i++)
			{
				string class_name_middleware = container.route.middleware[i];
				fn middleware_method = rtl::method(class_name_middleware, "actionMiddleware");
				await middleware_method(container);
			}
		}
		
		/* Call hook middleware */
		await @.callAsyncHook(AppHook::MIDDLEWARE, {
			"container": container,
		});
		
		/* Create layout */
		await this.createLayout(container);
		
		/* Call route */
		if (container.route != null and container.response == null)
		{
			await container.callMethod(container.route.method);
		}
	}
	
		
	#ifcode PHP then
	
	/**
	 * Create render container
	 */
	function createRenderContainer($ctx)
	{
		$container = new \Runtime\Web\RenderContainer($ctx);
		$container->request = $this->createRequest($ctx);
		return $container;
	}
	
	
	/**
	 * Returns POST
	 */
	function getPost($ctx)
	{
		$content_type = isset($_SERVER['HTTP_CONTENT_TYPE']) ? $_SERVER['HTTP_CONTENT_TYPE'] : "";
		if (substr($content_type, 0, strlen('application/json')) == 'application/json')
		{
			$json = file_get_contents("php://input");
			$json = @json_decode($json, true);
			return $json;
		}
		
		return $_POST;
	}
	
	
	/**
	 * Create request
	 */
	function createRequest($ctx)
	{
		$host = isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : "";
		$uri = isset($_SERVER['REQUEST_URI']) ? $_SERVER['REQUEST_URI'] : "";
		$method = isset($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD'] : "";
		$start_time = isset($_SERVER['REQUEST_TIME_FLOAT']) ? $_SERVER['REQUEST_TIME_FLOAT'] : "";
		$content_type = isset($_SERVER['Content-Type']) ? $_SERVER['Content-Type'] : "";
		
		$query = new \Runtime\Map($ctx);
		$payload = new \Runtime\Map($ctx);
		$cookies = new \Runtime\Map($ctx);
		foreach ($_GET as $key => $val) $query->setValue($ctx, $key, $val);
		
		/* Read POST */
		$post = $this->getPost($ctx);
		if ($post && gettype($post) == "array")
		{
			foreach ($post as $key => $val)
			{
				$payload->setValue($ctx, $key, \Runtime\rtl::NativeToObject($ctx, $val));
			}
		}
		
		/* Read Cookie */
		foreach ($_COOKIE as $key => $val)
		{
			$cookies->setValue($ctx,
				$key,
				new \Runtime\Web\Cookie($ctx,
					\Runtime\Dict::from([
						'name' => $key,
						'value' => $val,
					])
				)
			);
		}
		$arr = parse_url($uri);
		$path = isset($arr['path']) ? $arr['path'] : "";
		
		/* Create request */
		$r = new \Runtime\Web\Request($ctx,
			\Runtime\Dict::from([
				"host" => $host,
				"full_uri" => $uri,
				"uri" => $path,
				"method" => $method,
				"query" => $query->toDict($ctx),
				"payload" => $payload->toDict($ctx),
				"cookies" => $cookies->toDict($ctx),
				"start_time" => $start_time,
			])
		);
		return $r;
	}
	
	
	/**
	 * Output result
	 */
	function response($ctx, $response)
	{
		if ($response != null)
		{
			http_response_code($response->http_code);
			if ($response->cookies != null)
			{
				$keys = $response->cookies->keys($ctx);
				for ($i=0; $i<$keys->count($ctx); $i++)
				{
					$key = $keys->item($ctx, $i);
					$cookie = $response->cookies->item($ctx, $key);
					if ($cookie != null && $cookie->name)
					{
						$str = [];
						$str[] = "Set-Cookie: " . urlencode($cookie->name) .
							"=" . urlencode($cookie->value)
						;
						$str[] = "Expires=" . date(DATE_RFC822, $cookie->expires);
						if ($cookie->domain) $str[] = "Domain=" . $cookie->domain;
						if ($cookie->path) $str[] = "Path=" . $cookie->path;
						if ($cookie->secure) $str[] = "Secure";
						if ($cookie->httponly) $str[] = "HttpOnly";
						
						/* Set cookie */
						header( implode(";", $str) );
					}
				}
			}
			if ($response->headers != null)
			{
				$keys = $response->headers->keys($ctx);
				for ($i=0; $i<$keys->count($ctx); $i++)
				{
					$key = $keys->item($ctx, $i);
					$value = $response->headers->item($ctx, $key);
					header($key . ":" . $value);
				}
			}
			echo $response->getContent($ctx);
		}
		else
		{
			http_response_code(404);
			echo "404 Response not found";
		}
	}
	
	
	/**
	 * Css save
	 */
	static function css_save($css_class_names, $file_path)
	{
		$css_content = \Runtime\Web\Component::getCss( $css_class_names );
		
		$file_size = 0;
		if ($file_path)
		{
			if (file_exists($file_path)) $file_content = file_get_contents($file_path);
			if ($css_content != $file_content)
			{
				$dir_name = dirname($file_path);
				if (!file_exists($dir_name)) mkdir($dir_name, 0775, true);
				file_put_contents($file_path, $css_content);
			}
		}
	}
	
	#endif
}
