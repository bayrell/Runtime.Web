/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2023 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web;

use Runtime.lib;
use Runtime.BaseProvider;
use Runtime.Context;
use Runtime.Web.AppHook;
use Runtime.Web.BaseRoute;
use Runtime.Web.Layout;
use Runtime.Web.RenderContainer;
use Runtime.Web.RenderProvider;
use Runtime.Web.RouteInfo;
use Runtime.Web.RouteList;


class App extends BaseProvider
{
	
	/**
	 * Init app
	 */
	async Context init(Context c)
	{
		return c;
	}
	
	
	/**
	 * Start app
	 */
	async void start()
	{
	}
	
	
	/**
	 * Main entry point
	 */
	async void main()
	{
		await @.callAsyncHook(AppHook::MAIN, {});
		
		#ifdef BACKEND then
		this.renderBackend();
		#endif
		
		#ifdef FRONTEND then
		this.renderFrontend();
		#endif
	}
	
	
	/**
	 * Render backend
	 */
	async void renderBackend()
	{
		#ifcode PHP then
		$container = $this->createRenderContainer();
		$this->initContainer($container);
		$this->resolveContainer($container);
		$this->responseBackend($container->response);
		#endif
	}
	
	
	/**
	 * Render backend
	 */
	async void renderFrontend()
	{
		#ifcode ES6 then
		let context = Runtime.rtl.getContext();
		let core_ui_root = document.getElementById("core_ui_root");
		let core_ui_layout = document.getElementById("core_ui_layout");
		let layout = Runtime.rs.base64_decode_url(core_ui_layout.value);
		layout = Runtime.rtl.json_decode(layout);
		let layout_page_class_name = layout.getLayoutClassName();
		let provider = context.provider("Runtime.Web.RenderProvider");
		provider.renderRoot(core_ui_root, layout_page_class_name, layout);
		#endif
	}
	
	
	/**
	 * Resolve container
	 */
	async void initContainer(RenderContainer container)
	{
		Context context = @;
		context <= environments <= render_container <= container;
		@ = context;
		
		/* Init container */
		@.callAsyncHook(AppHook::INIT_CONTAINER, {
			"container": container,
		});
	}
	
	
	/**
	 * Resolve container
	 */
	async void resolveContainer(RenderContainer container, Dict models = null)
	{
		/* Find route */
		await this.findRoute(container);
		
		/* Init layout */
		await this.initLayout(container, models);
		
		/* Call route */
		await this.callRoute(container);
		
		/* Call hook response */
		await @.callAsyncHook(AppHook::RESPONSE, {
			"container": container,
		});
	}
	
	
	/**
	 * Init layout
	 */
	async void initLayout(RenderContainer container, Dict models = null)
	{
		/* Create layout */
		await @.callAsyncHook(AppHook::CREATE_LAYOUT, {
			"container": container,
		});
		
		if (container.layout == null)
		{
			container <= layout <= new Layout();
		}
		
		/* Set models */
		if (models)
		{
			container <= models <= models;
		}
		
		/* Setup request params */
		container <= layout <= route <= container.route;
		container <= layout <= request_host <= container.request.host;
		container <= layout <= request_uri <= container.request.uri;
		container <= layout <= request_full_uri <= container.request.full_uri;
		container <= layout <= request_query <= container.request.query;
		
		await @.callAsyncHook(AppHook::INIT_LAYOUT, {
			"container": container,
		});
		
		container <= layout <= await container.layout.init_layout();
	}
	
	
	/**
	 * Find route
	 */
	async void findRoute(RenderContainer container)
	{
		/* Call hook find route */
		await @.callAsyncHook(AppHook::FIND_ROUTE, {
			"container": container,
		});
		
		/* Find route */
		if (container.route == null)
		{
			RouteList routes = @.provider(classof RouteList);
			container.route = routes.findRoute( container );
		}
		
		/* Call hook found route */
		await @.callAsyncHook(AppHook::FIND_ROUTE_AFTER, {
			"container": container,
		});
	}
	
	
	/**
	 * Call route
	 */
	async void callRoute(RenderContainer container)
	{
		/* Call route before */
		await @.callAsyncHook(AppHook::CALL_ROUTE_BEFORE, {
			"container": container,
		});
		
		/* Call middleware */
		if (container.route and container.route.middleware)
		{
			for (int i=0; i<container.route.middleware.count(); i++)
			{
				string class_name_middleware = container.route.middleware[i];
				fn middleware_method = rtl::method(class_name_middleware, "actionMiddleware");
				await middleware_method(container);
			}
		}
		
		/* Call route before */
		await @.callAsyncHook(AppHook::MIDDLEWARE, {
			"container": container,
		});
		
		/* Call route */
		if (container.route != null and container.response == null)
		{
			await container.callMethod(container.route.method);
		}
		
		/* Call route after */
		await @.callAsyncHook(AppHook::CALL_ROUTE_AFTER, {
			"container": container,
		});
	}
	
	
	#ifcode PHP then
	
	/**
	 * Create render container
	 */
	function createRenderContainer($ctx)
	{
		$container = new \Runtime\Web\RenderContainer($ctx);
		$container->request = $this->createRequest($ctx);
		return $container;
	}
	
	
	/**
	 * Returns POST
	 */
	function getPost($ctx)
	{
		$content_type = isset($_SERVER['HTTP_CONTENT_TYPE']) ? $_SERVER['HTTP_CONTENT_TYPE'] : "";
		if (substr($content_type, 0, strlen('application/json')) == 'application/json')
		{
			$json = file_get_contents("php://input");
			$json = @json_decode($json, true);
			return $json;
		}
		
		return $_POST;
	}
	
	
	/**
	 * Create request
	 */
	function createRequest($ctx)
	{
		$host = isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : "";
		$uri = isset($_SERVER['REQUEST_URI']) ? $_SERVER['REQUEST_URI'] : "";
		$method = isset($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD'] : "";
		$start_time = isset($_SERVER['REQUEST_TIME_FLOAT']) ? $_SERVER['REQUEST_TIME_FLOAT'] : "";
		$content_type = isset($_SERVER['Content-Type']) ? $_SERVER['Content-Type'] : "";
		
		$query = new \Runtime\Map($ctx);
		$payload = new \Runtime\Map($ctx);
		$cookies = new \Runtime\Map($ctx);
		foreach ($_GET as $key => $val) $query->setValue($ctx, $key, $val);
		
		/* Read POST */
		$post = $this->getPost($ctx);
		if ($post && gettype($post) == "array")
		{
			foreach ($post as $key => $val)
			{
				$payload->setValue($ctx, $key, \Runtime\rtl::NativeToObject($ctx, $val));
			}
		}
		
		/* Read Cookie */
		foreach ($_COOKIE as $key => $val)
		{
			$cookies->setValue($ctx,
				$key,
				new \Runtime\Web\Cookie($ctx,
					\Runtime\Dict::from([
						'name' => $key,
						'value' => $val,
					])
				)
			);
		}
		$arr = parse_url($uri);
		$path = isset($arr['path']) ? $arr['path'] : "";
		
		$protocol = isset($_SERVER['HTTP_X_FORWARDED_PROTO']) ?
			$_SERVER['HTTP_X_FORWARDED_PROTO'] : "http";
		
		/* Create request */
		$r = new \Runtime\Web\Request($ctx,
			\Runtime\Dict::from([
				"host" => $host,
				"full_uri" => $uri,
				"uri" => $path,
				"method" => $method,
				"query" => $query->toDict($ctx),
				"payload" => $payload->toDict($ctx),
				"cookies" => $cookies->toDict($ctx),
				"headers" => \Runtime\Dict::from($_SERVER),
				"protocol" => $protocol,
				"start_time" => $start_time,
			])
		);
		return $r;
	}
	
	
	/**
	 * Output result
	 */
	function responseBackend($ctx, $response)
	{
		if ($response != null)
		{
			http_response_code($response->http_code);
			if ($response->cookies != null)
			{
				$keys = $response->cookies->keys($ctx);
				for ($i=0; $i<$keys->count($ctx); $i++)
				{
					$key = $keys->item($ctx, $i);
					$cookie = $response->cookies->item($ctx, $key);
					if ($cookie != null && $cookie->name)
					{
						setcookie
						(
							$cookie->name,
							$cookie->value,
							$cookie->getOptions()->_map
						);
					}
				}
			}
			if ($response->headers != null)
			{
				$keys = $response->headers->keys($ctx);
				for ($i=0; $i<$keys->count($ctx); $i++)
				{
					$key = $keys->item($ctx, $i);
					$value = $response->headers->item($ctx, $key);
					header($key . ":" . $value);
				}
			}
			
			if ($response instanceof \Runtime\Web\RedirectResponse)
			{
				header("Location:" . $response->redirect);
			}
			
			echo $response->getContent($ctx);
		}
		else
		{
			http_response_code(404);
			echo "404 Response not found";
		}
	}
	
	
	/**
	 * Css save
	 */
	static function css_save($css_class_names, $file_path)
	{
		$css_content = static::getCss( $css_class_names );
		
		$file_size = 0;
		if ($file_path)
		{
			$file_content = "";
			if (file_exists($file_path)) $file_content = file_get_contents($file_path);
			if ($css_content != $file_content)
			{
				$dir_name = dirname($file_path);
				if (!file_exists($dir_name)) mkdir($dir_name, 0775, true);
				file_put_contents($file_path, $css_content);
			}
		}
	}
	
	#endif
	
	
	/**
	 * Returns css
	 */
	static string getCss(Collection<string> class_names, Dict css_vars = null)
	{
		if (css_vars == null)
		{
			css_vars = @.callHook(AppHook::CSS_VARS, css_vars);
		}
		
		/* Get required components */
		Collection<string> components = static::getRequiredComponents(class_names);
		components = components.filter(lib::equalNot("")).removeDuplicatesIm();
		
		/* Get css */
		Collection<string> css = components.map
		(
			string (string component_name) use (css_vars)
			{
				if (component_name == "") return "";
				if (not rtl::method_exists(component_name, "css")) return "";
				fn f = rtl::method(component_name, "css");
				string css = f(css_vars);
				return css;
			}
		);
		
		css = css
			.map( string (string s) => rs::trim(s) )
			.filter( bool (string s) => s != "" )
		;
		
		return rs::trim( rs::join("\n", css) );
	}
	
	
	/**
	 * Returns required modules
	 * @param string class_name
	 * @return Collection<string>
	 */
	static void _getRequiredComponents
	(
		Vector<string> res,
		Map<string> cache,
		Collection<string> components
	)
	{
		if (components == null)
			return;
		
		for (int i=0; i<components.count(); i++)
		{
			string class_name = components.item(i);
			if (cache.get(class_name, false) == false)
			{
				cache.setValue(class_name, true);
				if (rtl::method_exists(class_name, "components"))
				{
					fn f = rtl::method(class_name, "components");
					Collection<string> sub_components = f();
					if (sub_components != null)
					{
						static::_getRequiredComponents(res, cache, sub_components);
					}
				}
				res.pushValue(class_name);
			}
		}
	}
	
	
	/**
	 * Returns all components
	 * @param Collection<string> components
	 * @return Collection<string>
	 */
	pure Collection<string> getRequiredComponents(Collection<string> components)
	{
		components = components.filter(lib::equalNot("")).removeDuplicatesIm();
		Vector<string> res = new Vector();
		Map<string> cache = new Map();
		static::_getRequiredComponents(res, cache, components);
		res = res.removeDuplicatesIm();
		return res.toCollection();
	}
	
	
	/**
	 * Render component
	 */
	string render(string class_name, var model)
	{
		return "";
	}
	
	
	/**
	 * Returns url
	 */
	string url(string route_name, Dict route_params = null)
	{
		RouteList routes = @.provider(classof RouteList);
		return routes.url(route_name, route_params);
	}
}
