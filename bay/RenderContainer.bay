/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web;

use Runtime.BaseObject;
use Runtime.Callback;
use Runtime.Component;
use Runtime.RenderContainer as BaseRenderContainer;
use Runtime.Serializer;
use Runtime.VirtualDom;
use Runtime.Entity.Factory;
use Runtime.Providers.RenderContent;
use Runtime.Web.ApiResult;
use Runtime.Web.BaseLayoutModel;
use Runtime.Web.BaseMiddleware;
use Runtime.Web.BaseModel;
use Runtime.Web.BasePageModel;
use Runtime.Web.BaseRoute;
use Runtime.Web.Cookie;
use Runtime.Web.Layout;
use Runtime.Web.RenderResponse;
use Runtime.Web.Request;
use Runtime.Web.Response;
use Runtime.Web.RouteInfo;
use Runtime.Web.RouteProvider;
use Runtime.Web.Hooks.AppHook;


class RenderContainer extends BaseRenderContainer
{
	public Request request = null;
	public Response response = null;
	public RouteInfo route = null;
	public Layout layout = null;
	public Dict<Cookie> cookies = {};
	public int http_code = 200;
	
	
	/**
	 * Resolve container
	 */
	async void resolve()
	{
		/* Find route */
		await this.findRoute();
		
		/* Resolve route */
		await this.resolveRoute();
		
		/* Create response */
		this.createResponse();
	}
	
	
	/**
	 * Find route
	 */
	async void findRoute()
	{
		/* Call hook find route */
		await @.hook(AppHook::FIND_ROUTE_BEFORE, {
			"container": this,
		});
		
		/* Exit if route find */
		if (this.route != null) return;
		if (this.response != null) return;
		
		/* Find route */
		RouteProvider routes = @.provider(classof RouteProvider);
		this.route = routes.findRoute(this.request);
		
		/* Call hook found route */
		await @.hook(AppHook::FIND_ROUTE_AFTER, {
			"container": this,
		});
	}
	
	
	/**
	 * Resolve route
	 */
	async void resolveRoute()
	{
		if (not this.route) return;
		if (this.response) return;
		
		/* Create layout */
		string layout_name = this.route.getLayoutName();
		this.createLayout(layout_name);
		
		/* Call route before */
		await @.hook(AppHook::ROUTE_BEFORE, {
			"container": this,
		});
		
		/* Call middleware */
		await this.callRouteMiddleware(this);
		
		/* Load layout data */
		await this.layout.loadData(this);
		
		/* Render route */
		if (this.route != null and this.response == null)
		{
			await this.route.render(this);
		}
		
		/* Call route after */
		await @.hook(AppHook::ROUTE_AFTER, {
			"container": this,
		});
	}
	
	
	/**
	 * Call route middleware
	 */
	async void callRouteMiddleware()
	{
		if (this.route)
		{
			await this.route.callMiddleware(this);
		}
		
		/* Call hook middleware */
		await @.hook(AppHook::ROUTE_MIDDLEWARE, {
			"container": this,
		});
	}
	
	
	/**
	 * Create response
	 */
	void createResponse()
	{
		if (this.response) return;
		if (not this.layout) return;
		
		/* Create and render component */
		Component component = rtl::newInstance(this.layout.component);
		component.container = this;
		component.layout = this.layout;
		VirtualDom vdom = component.renderApp();
		
		/* Render Virtual DOM */
		Vector content = [];
		RenderContent provider = new RenderContent();
		provider.render(vdom, content);
		
		/* Create response */
		this.response = new Response();
		this.response.http_code = this.http_code;
		this.response.content = rs::join("", content);
	}
	
	
	/**
	 * Set response
	 */
	void setResponse(Response response)
	{
		this.response = response;
	}
	
	
	/**
	 * Add cookie
	 */
	Response addCookie(Cookie cookie)
	{
		this.cookies.set(cookie.name, cookie);
	}
}