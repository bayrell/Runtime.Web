/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2025 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web;

use Runtime.re;
use Runtime.Method;
use Runtime.BaseObject;
use Runtime.SerializeInterface;
use Runtime.Serializer.IntegerType;
use Runtime.Serializer.MapType;
use Runtime.Serializer.ObjectType;
use Runtime.Serializer.StringType;
use Runtime.Serializer.VectorType;
use Runtime.TypeError;
use Runtime.Entity.Factory;
use Runtime.Exceptions.ItemNotFound;
use Runtime.Exceptions.RuntimeException;
use Runtime.Web.BaseMiddleware;
use Runtime.Web.BasePageModel;
use Runtime.Web.BaseRoute;
use Runtime.Web.RenderContainer;
use Runtime.Web.RouteList;


class RouteInfo extends BaseObject implements SerializeInterface
{
	string name = null;
	string uri = null;
	string uri_match = null;
	string domain = null;
	string label = null;
	string layout = null;
	string route_class = null;
	Dict data = null;
	Collection<Callback> middleware = null;
	Collection<string> params = [];
	Dict<string> matches = {};
	bool is_backend = false;
	int pos = 100;
	
	
	/**
	 * Constructor
	 */
	void constructor(Dict params = null)
	{
		parent();
		this._assign_values(params);
	}
	
	
	/**
	 * Serialize object
	 */
	static void serialize(ObjectType rules)
	{
		parent(rules);
		rules.addType("data", new MapType());
		rules.addType("domain", new StringType());
		rules.addType("label", new StringType());
		rules.addType("layout", new StringType());
		rules.addType("name", new StringType());
		rules.addType("matches", new MapType(new StringType()));
		rules.addType("params", new VectorType(new StringType()));
		rules.addType("pos", new IntegerType());
		rules.addType("route_class", new StringType());
		rules.addType("uri", new StringType());
		rules.addType("uri_match", new StringType());
	}
	
	
	/**
	 * Copy route
	 */
	RouteInfo copy()
	{
		return rtl::copy(this);
	}
	
	
	/**
	 * Returns layout name
	 */
	string getLayoutName()
	{
		if (this.layout != "") return this.layout;
		if (this.route_class != "")
		{
			fn f = new Method(this.route_class, "getLayoutName");
			return f.apply();
		}
		return "";
	}
	
	
	/**
	 * Compile route
	 */
	void compile()
	{
		if (this.uri_match == "")
		{
			this.uri_match = "^" ~ re::replace("\\/", "\\/", this.uri) ~ "$";
		}
		
		Collection matches = re::matchAll("{(.*?)}", this.uri);
		if (matches)
		{
			Vector<string> params = new Vector();
			
			for (int i=0; i<matches.count(); i++)
			{
				Collection arr = matches[i];
				string name = arr[1];
				this.uri_match = re::replace
				(
					"{" ~ name ~ "}",
					"([^\\/]*?)",
					this.uri_match
				);
				this.params.push(name);
			}
		}
		else
		{
			this.params = [];
		}
	}
	
	
	/**
	 * Add matches
	 */
	void addMatches(Collection matches)
	{
		for (int i=0; i<this.params.count(); i++)
		{
			string param_name = this.params.get(i);
			string match_value = matches.get(i);
			this.matches.set(param_name, match_value);
		}
	}
	
	
	/**
	 * Call middleware
	 */
	async void callMiddleware(RenderContainer container)
	{
		if (this.middleware)
		{
			for (int i = 0; i<this.middleware.count(); i++)
			{
				BaseMiddleware middleware = null;
				var item = this.middleware.get(i);
				
				/* Create middleware */
				if (rtl::isString(item))
				{
					middleware = rtl::newInstance(item);
				}
				else if (item instanceof Factory)
				{
					middleware = item.factory();
				}
				else if (item instanceof BaseMiddleware)
				{
					middleware = item;
				}
				
				/* Apply middleware */
				await middleware.apply(container);
			}
		}
		
		/* Call route class middleware */
		if (this.route_class)
		{
			string class_name = this.route_class;
			Method getMiddleware = new Method(class_name, "getMiddleware");
			if (getMiddleware.exists())
			{
				Collection<BaseMiddleware> items = getMiddleware.apply();
				for (int i=0; i<items.count(); i++)
				{
					BaseMiddleware middleware = items.get(i);
					await middleware.apply(container);
				}
			}
		}
	}
	
	
	/**
	 * Render route
	 */
	async void render(RenderContainer container)
	{
		throw new RuntimeException("RouteInfo is abstract class");
	}
}