/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web;

use Runtime.lib;
use Runtime.BaseDriver;
use Runtime.Exceptions.RuntimeException;
use Runtime.Web.Message;


class ObjectManager extends BaseDriver
{
	protected Map<var> objects = null;
	protected Vector<Dict> listeners = null;
	
	
	/**
	 * Constructor
	 */
	void constructor(string object_name = "")
	{
		parent(object_name);
		this.objects = new Map<var>();
		this.listeners = new Vector<Dict>();
	}
	
	
	
	/**
	 * Add object
	 */
	void addObject(var obj, string object_name = "")
	{	
		string object_name = obj.getObjectName();
		this.objects.setValue(object_name, obj);
		obj.manager = this;
	}
	
	
	
	/**
	 * Get object
	 */
	var getObject(string object_name)
	{
		var obj = null;
		obj = this.objects.get(object_name, null);
		return obj;
	}
	
	
	
	/**
	 * Remove object
	 */
	void removeObject(string object_name)
	{
		if (not this.objects.has(object_name))
		{
			var obj = this.objects.get(object_name, null);
			if (obj != null and obj.parent != null)
			{
				obj.parent.childs.removeValue(obj);
				obj.parent = null;
			}
			this.objects.removeValue(object_name);
		}
	}
	
	
	
	/**
	 * Remove object
	 */
	void removeObjectRecursive(string object_name)
	{
		Collection<string> keys = null;
		keys = this.objects.keys();
		
		keys = keys
			.filter
			(
				bool (string item_name) use (object_name) => rs::strpos(item_name, object_name) == 0
			)
			.sortIm( lib::sortDesc )
		;
		
		for (int i=0; i<keys.count(); i++)
		{
			string name = keys[i];
			this.removeObject(name);
		}
		
		/* Remove listeners */
		for (int i=this.listeners.count() - 1; i>=0; i--)
		{
			Dict item = this.listeners[i];
			if
			(
				rs::strpos(item["from"], object_name) == 0 or
				rs::strpos(item["object_name"], object_name) == 0
			)
			{
				this.listeners.removeValue(i);
			}
		}
	}
	
	
	
	/**
	 * Register listener
	 */
	public void registerListener(string from, string event_class_name, string object_name, string method_name = "")
	{
		for (int i=0; i<this.listeners.count(); i++)
		{
			Dict item = this.listeners[i];
			if (
				item["from"] == from and
				item["object_name"] == object_name and
				item["method_name"] == method_name and
				item["event_class_name"] == event_class_name
			)
			{
				return;
			}
		}
		this.listeners.pushValue
		{
			"from": from,
			"object_name": object_name,
			"event_class_name": event_class_name,
			"method_name": method_name,
		};
	}
	
	
	
	/**
	 * Find callback
	 */
	public void findListeners(string from, string event_class_name = "")
	{
		Vector<Dict> items = new Vector();
		for (int i=0; i<this.listeners.count(); i++)
		{
			Dict item = this.listeners[i];
			if
			(
				item["from"] == from and
				(event_class_name == "" or item["event_class_name"] == event_class_name)
			)
			{
				items.pushValue(item);
			}
		}
		return items.toCollection();
	}
	
	
	
	/**
	 * Handle messages
	 */
	async void sendMessage(Message msg)
	{
		if (msg.data == null) return;
		
		Map<bool> hash = new Map();
		Collection<Dict> items = this.findListeners(msg.from, msg.data.getClassName());
		for (int i=0; i<items.count(); i++)
		{
			Dict item = items[i];
			
			string object_name = item["object_name"];
			string method_name = item["method_name"];
			
			var obj = this.getObject(object_name);
			if (obj != null)
			{
				if (rtl::method_exists(obj, method_name))
				{
					fn f = rtl::method(obj, method_name);
					await f(msg);
				}
			}
			
			if (not hash.has(object_name))
			{
				while (obj != null)
				{
					await obj.handleMessage(msg);
					obj = obj.parent;
				}
				hash.setValue(object_name, true);
			}
		}
	}
	
	
	
	/**
	 * Set parent
	 */
	void changeParent(var child_obj, var parent_obj)
	{
		safe (this.mutex_objects)
		{
			if (child_obj.parent != null)
			{
				child_obj.parent.childs.removeValue(child_obj);
			}
			
			child_obj.parent = parent_obj;
			
			if (parent_obj != null)
			{
				if (parent_obj.childs.indexOf(child_obj) == -1)
				{
					parent_obj.childs.pushValue(child_obj);
				}
			}
		}
	}
	
}